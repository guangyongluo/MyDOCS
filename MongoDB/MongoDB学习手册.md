### MongoDB学习手册
简介：MongoDB时一个面向文档(document-oriented)的数据库，而不是关系型数据库。不采用关系型主要是为了获得更好的扩展性。与关系数据库相比，面向文档的数据库不再有“行”
的概念，取而代之的是更为灵活的“文档”(document)模型。通过在文档中嵌入文档和数组，面向文档的方法能够仅使用一条记录来表现复杂的层次关系，这与使用现代面向对象语言的开
发者对数据的看法一致。另外，不再有预定义模式(predefinded schema)：文档的键和值不再是固定的类型和大小，由于没有固定的模式，根据需要添加或删除字段变得更容易了。
MongoDB的设计采用横向扩展的方式，面向文档的数据模型使它能够很容易地在多台服务器之间进行数据分析。MongoDB能自动处理跨集群的数据和负载，自动重新分配文档，以及将用户
请求路由到正确的机器上。MongoDB一个主要的目标是提供卓越的性能，这很大程度上决定了MongoDB的设计。

###### MongeDB社区版安装
在Suse Linux Enterprise 12.3上安装官网上的四个RPM包即可。

###### MongoDB基本概念
1. 文档是MongoDB中数据的基本单元，非常类似于关系数据库管理系统中的行，但更具表现力；
2. 集合(collection)可以看成时一个拥有动态模式(dynamic schema)的表；
3. MongoDB的一个实例可以拥有多个相互独立的数据库(database)，每一个数据库都拥有自己的集合；
4. 每一个文档都有一个特殊的键"_id"，这个键在文档所属的集合中时唯一的；
5. MongoDB自带了一个简单但功能强大的JavaScript shell，可用于管理MongoDB的实例或数据操作。

文档是MongoDB的核心概念。文档就是键值对的一个有序集。文档的键时字符串，MongoDB不但区分类型，而且区分大小写。例如：
```
{"foo":3}和{"foo":"3"}是不同的文档
{"foo":3}和{"Foo":3}是不同的文档
```
还有一个非常重要的说明，MongoDB的文档不能有重复的键。  

集合就是一组文档，如果将文档比作关系型数据库中的行，那么集合就相当于关系型数据库中的一个表。集合时动态模式的，这意味着一个集合里面的文档可以是各式各样的，没有固定的
模式。子集合时组织集合的一种惯例，分隔不同命名空间的子集合使用`.`来划分。虽然子集合没有任何特别的属性，但它们却非常有用，因而很多MongoDB工具都使用了子集合。

在MongoDB中多个集合可以组成数据库。一个MongoDB实例可以承载多个数据库，每个数据库拥有0个或者多个集合。每个数据库都有独立的权限，即便是在磁盘上，不同的数据库也放置在
不同的文件中。按照经验我们将有关一个应用程序的所有数据都存储在同一个数据库中。要想在同一个MongoDB服务器上存放多个应用或者有用户的数据，就需要使用不同的数据库。要注意
的是数据库最终会变成文件系统里的文件，而数据库名就是相应的文件名，这是数据库名最多为64字节。

###### MongoDB数据类型
1. null：用于表示空值或者不存在的字段；
2. 布尔型：布尔类型有两个值true和false；
3. 数值：shell默认使用64位浮点型数值。对于整数可以使用NumberInt(表示4字节带符号整数)类或NumberLong(表示8字节带符号整数)类；
4. 字符串：UTF-8字符串都可表示为字符串类型的数据；
5. 日期：日期被存储为自新纪元以来经过的毫秒数；
6. 正则表达式：查询时，使用正则表达式作为限定条件，语法也与JavaScript的正则表达式语法相同；
7. 数组：数据列表或数据集可以表示为数组；
8. 内嵌文档：文档可嵌套其他文档，被嵌套的文档作为父文档的值；
9. 对象id：对象id是一个12字节的ID，是文档的唯一标识；
10. 二进制数据：二进制数据是一个任意字节的字符串。它不能直接在shell中使用。如果要将非UTF-8字符保存到数据库中，二进制数据是唯一的方式；
11. 代码：查询和文档中可以包含任意JavaScript代码。

####### MongoDB 插入、删除和更新
1. 插入指令
```
#插入文档
db.foo.insert({"bar":"baz"})
#批量插入,接受一个文档数组
db.foo.batchInsert([{"_id":0}, {"_id":1}, {"_id":2}])
```
2. 删除指令
```
#删除所有文档
db.foo.remove()
#可以传递一个查询参数，只有符合查询参数的文档才被删除
db.foo.remove({"opt-out":true})
#清空集合包含元数据全部被删除
db.foo.drop()
```
3. 更新指令
```
#更新整个文档
db.foo.update({查询文档}, {修改后的文档}))
#更新某个字段，不存在就添加，存在就更新
db.foo.update({查询文档}, {"$set": {"需要更新的字段":"更新的值"}})
#加或减某个数字字段
db.foo.update({查询文档}, {"$inc": {"需要更新的字段":"数字"}})
#添加数组字段中的元素,没有就创建一个新的数组
db.foo.update({查询文档}, {"$push": {"数组字段":{数组元素文档}}})
#使用$push添加多个值
db.foo.update({查询文档}, {"$push": {"需要添加多个值的字段":{"$each":[数组元素]}}})
#限定插入多个值的数目，$slice表示最后插入的数量
db.foo.update({查询文档}, {"$push": {"需要添加多个值的字段":{"$each":[数组元素], "$slice": 负整数}}})
#将数组作为数据集使用时保证数组内的元素不会重复
db.foo.update({查询文档}, {"$addToSet: {"需要更新的字段":"要添加的数组元素"}})
#删除数组字段的元素: 1表示从数组末尾删除；2.表示从数组头部删除
db.foo.update({查询文档}, {"$pop": {"key":1}})
#删除数组字段的元素还可以根据元素值删除
db.foo.update({查询文档}, {"$pull": {"key":"value"}})
#upsert是一种特殊的更新。要是没有找到符合更新条件的文档，就会以这个条件和更新文档为基础创建一个新的文档。如果找到了匹配的文档，则正常更新。
```
4. 查询指令
```
#基本查询 {}空文档表示匹配集合所有全部内容
db.foo.find({查询文档},{需要返回键的文档})
#查询条件 $lt, $lte, $gt, $gte分别对应< <= >和>=
db.users.find({"age":{"$gte" : 18, "$lte" : 30}})
#OR查询:$in可以对单个键进行OR查询，$or可以对多个键进行OR查询
db.raffle.find({"ticket_no":{"$in":[725,542,390]}})
db.raffle.find({"$or":[{"ticket_no":725},{"winner":true}]})
#元条件语句，即可以用在任何其他条件上。
db.user.find({"id_num":{"$not" : {"$mod":[5, 1]}}})
#查询数组
#如果需要多个元素来匹配数组，就要用"$all"了
db.food.find({"fruit" : {$all : ["apple", "banana"]}})
#查询特定长度的数组，使用$size
db.food.find({"fruit" : {"$size" : 3}})
#嵌套查询，查询一个完整的子文档，那么子文档必须精确匹配包括键的顺序
db.people.find({"name":{"first":"Joe","last":"Schmoe"}})
#嵌套查询，针对内嵌文档的特定键查询
db.people.find({"name.first":"Joe","name.last":"Schmoe"})
```
**要注意的是针对数组元素的范围查询只要有任意元素有一个与查询的任意条件相匹配也要成功返回。也就是说对于数组元素的范围查询不要求每个元素满足条件，只要数组中的任意
元素能够分别满足这个范围查询就能成功返回。可以使用$elemMatch要求MongoDB同时使用查询条件中的两个语句与一个数组元素进行比较。**

MongoDB使用游标返回find结果。客户端对游标的实现通常能够对最终结果进行有效的控制。可以限制结果的数量，略过部分结果，根据任意键按任意顺序地组合对结果进行各种排序
，或者是执行其他一些强大的操作。要迭代结果，可以使用游标的next方法。也可以使用hasNext来查看游标中是否还有其他结果。最常用的查询选项就是限制返回结果的数量、忽略
一定的结果以及排序。所有这些选项一定要在查询被发送到服务器之前指定。

###### MongoDB索引
在MOngoDB建立索引能提高查询效率，只需要扫描索引(一般是B+树实现)其相当与原集合的一小部分，把这一小部分加载到内存就可以大大的提高效率，如果没有建立索引，在查询时，
MongDB必须扫描全表，在数据量大时，效率差别就很明显，对于包含一个没有索引的排序操作的查询，服务器必须在返回任何结果之前将所有的文档加载到内存中来进行排序。索引是
特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列值进行排序的一种数据结构。

1. 默认索引：存储在MongoDB集合中的每个文档(document)都有一个默认的主键"_id"，如果我们在添加新的文档时，没有指定"_id"值时，MOngoDB会创建一个ObjectId值，并自动
创建一个索引在"_id"键上，默认索引的名称是"_id_"，并无法删除。查看一个集合上的索引语法`db.collection.getIndexes()`
2. 单列索引：对文档中单个字段创建索引或者对内嵌文档的单个字段创建索引，语法：`db.collection.createIndex({field:boolean})` boolean:对于升序索引指定为1，降序
指定-1
3. 组合索引：可以同时对多个键创建组合索引，语法：`db.collection.createIndex({field1:boolean, field2:boolean})` boolean的意义与单列索引一样，使用组合索引时
需要符合最右优先原则。
4. 内嵌文档索引：我们可以对内嵌文档的属性进行索引，其形式与对外部文档的属性创建索引一致。

删除索引：我们对已经创建索引进行删除，可以针对具体的集合中索引进行删除，也可以对所有的集合中的索引删除。删除方法1.使用索引名称进行删除`db.collection.dropIndex(index)`
，删除方法2.删除集合上所有的索引`db.collection.dropIndexes()`我们对集合中的所有索引进行删除，除了_id索引除外。

###### MongoDB聚合函数

###### MongoDB副本集

###### MongoDB切片

###### MongoDB认证、添加用户、用户权限控制
1. 创建用户账号：在创建用户前，我们使用createUser(user, writeConcern)，该方法以前是addUser()，但是已经不能用了，使用createUser()代替。其中user的文档定义如下：
```
{  
	user:"<name>",
	pwd:"<cleartext password>",
	customData:{<any information>},
	roles:[
		{role:"<role>", db:"<database>"} | "<role>",
		...
	],
	authenticationRestrictions:[
		{
			clientSource:["<IP>"|"<CIDR range>", ...]
			serverAddress:["<IP>"|"<CIDR range>", ...]
		},
		...
	]
}
```
writeConcern:该文档是该操作的关注等级
- w选项：允许的值分别是1、0、大于1的值、“majority”;
- j选项：确保mongod实例写数据到磁盘上的journal(日志)，这可以确保mongod意外关闭不会丢失数据。设置true启用。
- wtimeout选项：指定一个时间限制，以毫秒为单位。wtimeout只适用于w大于1。

创建用户所需的字段

|字段|格式|描述|
|:--------:|:--------:|:----------------:|
|user|字符串|独一无二的用户名|
|roles|数组|一个用户的角色数组，MongoDB提供了大量可以分配的角色|
|pwd|字符串|可选，账号密码，该字段可以是散列值或字符串，不过存储是按照散列值的方式存储的|
|customData|任何数据|可选，可以为任何信息。此字段可用于存储管理员希望与此特定用户关联的任何数据。例如，这可能时用户的全名或雇员id|
|authenticationRestrictions|array|可选，服务器在创建用户上强制执行的身份验证限制。指定可连接服务器的访问用户的IP地址或者指定可连接服务器的服务器ip地址列表|

简单来说，clientSource 就是服务器针对客户端的IP 做白名单控制。serverAddress 就是客户端针对服务端的IP 做白名单控制。也就是说，客户端和服务器端都可以维护一个
白名单进行限制。

可分配的用户账号角色 

|命令|用例和描述|
|:--------:|:----------------:|
|read|让用户能够读取当前数据库中的任何集合的数据|
|readAnyDatabase|和read一样能够读取任何集合的数据，不过该用户可以读取任何数据库的，不在是指定数据库|
|readWrite|用户可以读写当前数据库中的任何集合，读写包括插入、删除、更新文档以及创建、重命名、删除集合|
|readWriteAnyDatabase|与readWrite权限一样，不过其可以操作所有数据库，不再只能操作指定数据库|
|dbAdmin|让用户能够读写当前数据库以及清理、修改、压缩、获取统计信息和执行检查|
|dbAdminAnyDatabase|与dbAdmin权限一样，不过其可以操作所有数据库，不再只能操作指定数据库|
|dbOwner|数据库所有者可以在数据库上执行任何管理操作。这个角色结合readWrite、dbAdmin、userAdmin|
|clusterManager|3.4版本以后新特性，提供集群的管理和监视操作。具有此角色的用户可以访问、配置和访问本地数据库，它们分别用于分片和复制中|
|clusterMonitor|3.4版本新特性，提供对监视工具的只读访问权限，比如MongoDB Cloud Manager和Ops Manager|
|hostManager|提供监视和管理服务器的能力|
|clusterAdmin|让用户能够管理MongoDB，包括连接、集群、复制、列出数据库、创建数据库、和删除数据库|
|userAdmin|让用户能够在当前数据库中创建和修改用户账户|
|userAdminAnyDatabase|与userAdmin相同，过其可以操作所有数据库，不再只能操作指定数据库|
|backup|3.4新特性，提供备份数据所需的最小权限。该角色有足够的权限使用MongoDB Cloud Manager、Ops Manager的备用代理或者使用mongodump|
|restore|3.6新特性，提供对非系统集合的转换。提供从备份中恢复数据所需的特权，这些备份不会对数据进行重新配置。当还原数据时，此角色足够|
|root|提供对所有资源的访问权限。集合了readWriteAnyDatabase、dbAdminAnyDatabase、userAdminAnyDatabase、clusterAdmin、backup这些角色的所有权限。|
|__system|mongodb将此角色分配给表示集群成员的用户对象，该角色赋予其持有者对数据库中的任何对象采取任何操作。请将此角色用于代表应用程序或管理员的用户对象，而不是在异常情况下。|

我们创建完一个用户后，可以使用show users或者使用db.getUser(username),db.getUsers()来查看当前数据库的所有用户。如图，我们可以看到我们在设置角色是，
若未指定数据库，则其默认当前数据库