### MongoDB学习手册
简介：MongoDB时一个面向文档(document-oriented)的数据库，而不是关系型数据库。不采用关系型主要是为了获得更好的扩展性。与关系数据库相比，面向文档的数据库不再有“行”
的概念，取而代之的是更为灵活的“文档”(document)模型。通过在文档中嵌入文档和数组，面向文档的方法能够仅使用一条记录来表现复杂的层次关系，这与使用现代面向对象语言的开
发者对数据的看法一致。另外，不再有预定义模式(predefinded schema)：文档的键和值不再是固定的类型和大小，由于没有固定的模式，根据需要添加或删除字段变得更容易了。
MongoDB的设计采用横向扩展的方式，面向文档的数据模型使它能够很容易地在多台服务器之间进行数据分析。MongoDB能自动处理跨集群的数据和负载，自动重新分配文档，以及将用户
请求路由到正确的机器上。MongoDB一个主要的目标是提供卓越的性能，这很大程度上决定了MongoDB的设计。

###### MongeDB社区版安装
在Suse Linux Enterprise 12.3上安装官网上的四个RPM包即可。

###### MongoDB基本概念
1. 文档是MongoDB中数据的基本单元，非常类似于关系数据库管理系统中的行，但更具表现力；
2. 集合(collection)可以看成时一个拥有动态模式(dynamic schema)的表；
3. MongoDB的一个实例可以拥有多个相互独立的数据库(database)，每一个数据库都拥有自己的集合；
4. 每一个文档都有一个特殊的键"_id"，这个键在文档所属的集合中时唯一的；
5. MongoDB自带了一个简单但功能强大的JavaScript shell，可用于管理MongoDB的实例或数据操作。

文档是MongoDB的核心概念。文档就是键值对的一个有序集。文档的键时字符串，MongoDB不但区分类型，而且区分大小写。例如：
```
{"foo":3}和{"foo":"3"}是不同的文档
{"foo":3}和{"Foo":3}是不同的文档
```
还有一个非常重要的说明，MongoDB的文档不能有重复的键。  

集合就是一组文档，如果将文档比作关系型数据库中的行，那么集合就相当于关系型数据库中的一个表。集合时动态模式的，这意味着一个集合里面的文档可以是各式各样的，没有固定的
模式。子集合时组织集合的一种惯例，分隔不同命名空间的子集合使用`.`来划分。虽然子集合没有任何特别的属性，但它们却非常有用，因而很多MongoDB工具都使用了子集合。

在MongoDB中多个集合可以组成数据库。一个MongoDB实例可以承载多个数据库，每个数据库拥有0个或者多个集合。每个数据库都有独立的权限，即便是在磁盘上，不同的数据库也放置在
不同的文件中。按照经验我们将有关一个应用程序的所有数据都存储在同一个数据库中。要想在同一个MongoDB服务器上存放多个应用或者有用户的数据，就需要使用不同的数据库。要注意
的是数据库最终会变成文件系统里的文件，而数据库名就是相应的文件名，这是数据库名最多为64字节。

###### MongoDB数据类型
1. null：用于表示空值或者不存在的字段；
2. 布尔型：布尔类型有两个值true和false；
3. 数值：shell默认使用64位浮点型数值。对于整数可以使用NumberInt(表示4字节带符号整数)类或NumberLong(表示8字节带符号整数)类；
4. 字符串：UTF-8字符串都可表示为字符串类型的数据；
5. 日期：日期被存储为自新纪元以来经过的毫秒数；
6. 正则表达式：查询时，使用正则表达式作为限定条件，语法也与JavaScript的正则表达式语法相同；
7. 数组：数据列表或数据集可以表示为数组；
8. 内嵌文档：文档可嵌套其他文档，被嵌套的文档作为父文档的值；
9. 对象id：对象id是一个12字节的ID，是文档的唯一标识；
10. 二进制数据：二进制数据是一个任意字节的字符串。它不能直接在shell中使用。如果要将非UTF-8字符保存到数据库中，二进制数据是唯一的方式；
11. 代码：查询和文档中可以包含任意JavaScript代码。

####### MongoDB 插入、删除和更新
1. 插入指令
```
#插入文档
db.foo.insert({"bar":"baz"})
#批量插入,接受一个文档数组
db.foo.batchInsert([{"_id":0}, {"_id":1}, {"_id":2}])
```
2. 删除指令
```
#删除所有文档
db.foo.remove()
#可以传递一个查询参数，只有符合查询参数的文档才被删除
db.foo.remove({"opt-out":true})
#清空集合包含元数据全部被删除
db.foo.drop()
```
3. 更新指令
```
#更新整个文档
db.foo.update({查询文档}, {修改后的文档}))
#更新某个字段，不存在就添加，存在就更新
db.foo.update({查询文档}, {"$set": {"需要更新的字段":"更新的值"}})
#加或减某个数字字段
db.foo.update({查询文档}, {"$inc": {"需要更新的字段":"数字"}})
#添加数组字段中的元素,没有就创建一个新的数组
db.foo.update({查询文档}, {"$push": {"数组字段":{数组元素文档}}})
#使用$push添加多个值
db.foo.update({查询文档}, {"$push": {"需要添加多个值的字段":{"$each":[数组元素]}}})
#限定插入多个值的数目，$slice表示最后插入的数量
db.foo.update({查询文档}, {"$push": {"需要添加多个值的字段":{"$each":[数组元素], "$slice": 负整数}}})
#将数组作为数据集使用时保证数组内的元素不会重复
db.foo.update({查询文档}, {"$addToSet: {"需要更新的字段":"要添加的数组元素"}})
#删除数组字段的元素: 1表示从数组末尾删除；2.表示从数组头部删除
db.foo.update({查询文档}, {"$pop": {"key":1}})
#删除数组字段的元素还可以根据元素值删除
db.foo.update({查询文档}, {"$pull": {"key":"value"}})
#upsert是一种特殊的更新。要是没有找到符合更新条件的文档，就会以这个条件和更新文档为基础创建一个新的文档。如果找到了匹配的文档，则正常更新。
```
4. 查询指令
```
#基本查询 {}空文档表示匹配集合所有全部内容
db.foo.find({查询文档},{需要返回键的文档})
#查询条件 $lt, $lte, $gt, $gte分别对应< <= >和>=
db.users.find({"age":{"$gte" : 18, "$lte" : 30}})
#OR查询:$in可以对单个键进行OR查询，$or可以对多个键进行OR查询
db.raffle.find({"ticket_no":{"$in":[725,542,390]}})
db.raffle.find({"$or":[{"ticket_no":725},{"winner":true}]})
#元条件语句，即可以用在任何其他条件上。
db.user.find({"id_num":{"$not" : {"$mod":[5, 1]}}})
#查询数组
#如果需要多个元素来匹配数组，就要用"$all"了
db.food.find({"fruit" : {$all : ["apple", "banana"]}})
#查询特定长度的数组，使用$size
db.food.find({"fruit" : {"$size" : 3}})
#嵌套查询，查询一个完整的子文档，那么子文档必须精确匹配包括键的顺序
db.people.find({"name":{"first":"Joe","last":"Schmoe"}})
#嵌套查询，针对内嵌文档的特定键查询
db.people.find({"name.first":"Joe","name.last":"Schmoe"})
```
**要注意的是针对数组元素的范围查询只要有任意元素有一个与查询的任意条件相匹配也要成功返回。也就是说对于数组元素的范围查询不要求每个元素满足条件，只要数组中的任意
元素能够分别满足这个范围查询就能成功返回。可以使用$elemMatch要求MongoDB同时使用查询条件中的两个语句与一个数组元素进行比较。**

MongoDB使用游标返回find结果。客户端对游标的实现通常能够对最终结果进行有效的控制。可以限制结果的数量，略过部分结果，根据任意键按任意顺序地组合对结果进行各种排序
，或者是执行其他一些强大的操作。要迭代结果，可以使用游标的next方法。也可以使用hasNext来查看游标中是否还有其他结果。最常用的查询选项就是限制返回结果的数量、忽略
一定的结果以及排序。所有这些选项一定要在查询被发送到服务器之前指定。