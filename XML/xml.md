### XML简介
XML的全称是Extensible Markup Language,意思是可扩展的标记语言。它是标准通用标记语言(Standard Generalized Markup Language, SGML)的一个子集。它以一种开放的、自我描述的方式定义了数据结构。在描述数据内容的同时能突出对结构的描述，从而体现出数据与数据之间的关系。XML不能描述页面的排版和表现形式，它只是用于描述数据和数据的结构。也就是说，XML将数据和显示分开了，我们可以为这些数据设计不同的排版和表现形式，而数据本身不需要做任何的修改。采用XML来表示数据，我们能够很容易地读懂XML文档，而计算机也能够很好地进行识别和处理。XML表示数据的方式真正做到了独立与应用系统，并且数据能够重用，一份数据可以应用于不同的场合。有时候，XML文档也被看做是文档的数据库化和数据的文档化。

##### XML对文档的格式要求严格
1. 开始标签必须要有一个结束标签配套；
2. 空元素标签必须被关闭；
3. 所有的标签都区别大小写；
4. 所有的标签都必须合理嵌套；
5. 所有标签的属性值必须用双引号（\" \"）或单引号(\' \')括起来；
6. XML有且只有一个根元素。

### XML文档
每一个XML文档都有一个逻辑结构和一个物理结构。物理上而言，文档由称为实体(entities)的存储单元组成，实体都具有内容并且都通过实体的名字进行标识(文档实体和外部DTD子集除外)。实体可以是一段文本、一个文件、一个数据库记录或其他包含数据的项目。一个实体可以引用其他的实体，从而将它们包含在文档中。文档开始于“根(root)”或文档实体(document entity)。格式良好的XML文档形成了一种层次树结构，而这个数的根就是文档实体，与其他实体不同，文档实体没有名字，只是用于表示文档树的根。XML文档的根元素被称为文档元素(document element)，它和在其外部出现的处理命令、注释等作为文档实体的子节点，而根元素本身和其内部的子元素也是一颗树。  
实体可以包含已分析(parsed)的或未分析的(unparsed)数据。已分析的数据由字符组成，其中一些字符组成字符数据，另一些字符组成标记。已分析的实体(parsed entity)内容被称为它的替换文本，这个文本被看成是文档整体的一部分。在XML处理器分析XML文档时，凡是文档中出现引用已分析实体的地方，都将被该实体的内容所替换。  
未分析的实体(unparsed entity)是一种资源，它的内容可以是也可以不是文本，并且，如果是文本的话，可以不是XML文本。每一个未分析的实体有一个相关联的用名字标识的记号(notation)。除了要求XML处理器能向引用程序提供可用的实体和记号的标识符之外，XML对未分析的实体内容不作任何限制。  
已分析的实体以实体引用的方式通过名字来调用；未分析的实体通过ENTITY或ENTITIES属性中给出的名字来调用。  
逻辑上而言，文档由声明、元素、注释、字符引用和处理指令组成，在文档中，所有这些都是通过显示地标记(markup)来指明的。  
XML标记(markup)包括开始标签(tag)、结束标签、空元素标签、实体引用、字符引用、注释、CDATA段定界符、文档类型声明、处理指令、XML声明、文本声明及任何在文档实体顶层的空白(在文档元素之外，且不在任何其他的标记内部)。其他所有非标记的文本组成文档的字符数据。  
XML文档在逻辑上主要由以下5个部分组成：
* XML声明；
* 文档类型声明；
* 元素；
* 注释；
* 处理指令。

##### XML声明
XML文档总是以一个XML声明开始，其中指明所用的XML版本、文档的编码、文档的独立性信息。其格式为：`?xml version info [encoding info] [doc independence]`。文档编码声明默认是UTF-8，如果要用中文，可以在声明中加上`encoding="bg2312"`。如果文档不依赖于外部文档，可以在XML声明中加上`standalone="no"`来声明这个文档是独立的文档。**注意：XML声明必须位于文档的第一行，前面不能有任何字符。**

##### 文档类型声明
我们可以用DTD(Document Type Definition，文档类型定义)来规范XML文档。通过文档类型声明，指出XML文档所用的DTD。文档类型声明有两种形式，一种是声明DTD在一个外部的文件中，例如：`<!DOCTYPE greeting SYSTEM "hello.dtd"`另一种是直接在XML文档中给出DTD，例如：
```
<!DOCTYPE greeting [
    <!ELEMENT greeting (#PCDATA)
]>
```

##### 元素
在XML中，元素由开始标签、元素内容和结束标签构成。空元素则由空元素标签构成。每一个元素有一个用名字标识的类型，同时它可以有一个属性说明集，每一个属性说明有一个名字和一个值。给元素命名时，还需要遵守以下规范：
* 名称只能以字母、下划线(_)或者冒号(:)开头；
* 名称中可以包含字母、数字、下划线及其他在XML标准中允许的字符；
* 名字不能包含空格；
* 名称中尽可能不要使用冒号(:)，因为冒号在名称空间中被用于分隔名称空间前缀和本地部分。

元素的类型：
* 空元素 `<student/>`
* 带有属性的空元素`<student name="张三" age="18"/>`
* 带有内容的元素：
```
<students>
    <student>
        <name>张三</name>
        <age>18</age>
    </student>
</students>
```

元素内容的类型：
* 子元素：子元素本身也是元素，被嵌套在上层元素之内；
* 字符数据：在一个元素内容中，字符数据可以是不包含任何标记的起始定界符和CDATA段的结束定界符的任意字符串，也就是说在元素的内容中，字符数据不能有和号(&)和小于号(<)，也不能有字符串“]]>”。在CDATA段中，字符数据可以是不包括CDATA段的结束定界符的任意字符串。
* 字符引用和预定义实体引用：在XML中，提供了5个预定义的实体引用，如下表：  

|字符|字符引用(十进制代码)|字符引用(十六进制代码)|预定义实体引用|
|:----:|:------:|:------:|:----:|
|<|`&#60;`|`&#x3c;`|`&lt;`|
|>|`&#62;`|`&#x3e;`|`&gt;`|
|"|`&#34;`|`&#x22;`|`&quot;`|
|'|`&#39;`|`&#x27;`|`&apos;`|
|&|`&#38;`|`&#x26;`|`&amp;`|

* CDATA段：CDATA段中包含的都是纯字符数据，在字符数据可以出现的任何地方都可以使用CDATA段。CDATA段主要用于需要将整个文本解释为字符数据。CDATA段中的内容不被XML处理器分析，所以可以在其中包含任意的字符。CDATA段以字符串“<![CDATA[”开始，以字符串“]]>”结束。

##### 注释
XML、HTML的注释都是以`<!--`开头，以`-->`结尾的形式标注一些解释说明的文字，位于注释之间的数据将被XML处理忽略。需要注意以下五点信息：
1. 注释不能出现在XML声明之前，XML声明必须是文档最前面的部分；
2. 注释不能出现在标记中；
3. 注释可以包围和隐藏标记，但要注意的是，在注释掉标记之后，要保证剩余的文本仍然是一个结构完整的XML文档；
4. 字符串“--”不能再注释中出现；
5. 在XML中不允许注释以“--->”结尾。

##### 处理命令
处理命令(processing Instructions, PI)允许文档中包含由应用程序来处理的指令。在XML文档中，有可能会包含一些非XML格式的数据，这些数据XML处理器无法处理，我们就可以通过处理指令来通知其他应用程序来处理这些数据。例如使用样式表单的处理指令：`<?xml-stylesheet href="hello.css" type="text/css"?>`。xml-stylesheet处理指令总是放在XML声明之后，第一个元素之前。其他的处理指令可以放在除标记的内部和XML声明之前的任何位置。要注意，虽然XML声明和处理指令的语法形式相似，但XML声明并不是处理指令，XML处理程序对XML声明和处理指令采取的是不同的处理方式。

##### 空白处理
XML处理器总是将文档中不是标记的所有字符都传递给应用程序，一个进行有效性验证的XML处理器会通知应用程序这些字符中的哪一些组成了出现在元素内容中的空白。当在元素中可以用特殊的属性xml:space来通知应用程序保留此元素中的空白。它的值必须是default和preserve两者之一，也可以两个都取。


##### 行尾处理
在XML空白字符中，有两个是标准的ASCII码行尾控制符：回车(CR,#xA)和换行(LF,#xD)。在Windows平台下，采用#xD#xA的组合作为行分隔符，而Linux、Unix系统则采用#xA作为行分隔符，在Mac OS下，采用#xD作为行分隔符。为了简化应用程序的工作，XML处理器在解析之前，要将所有的两字符序列#xD#xA，以及单字符#xD转换成单个的#xA字符。

##### 语言标识
在文档处理中还可以使用一个特殊的元素属性xml:lang来指出XML文档中任何元素的内容和属性的值所使用的语言。

### XML名称空间
XML名称空间的概念是通过给元素或属性加上一个名称空间，来唯一标识一个元素或属性。名称空间通过使用一系列的保留属性来声明，这种属性的名字必须是以xmlns或以xmlns:作为前缀。与其他任何XML属性一样，这些属性可以直接或以默认的方式给出。有以下两种形式的名称空间声明：
1. 第一种形式：<元素名 xmlns:prefixname="URI">
元素名是指在哪一个元素上声明名称空间，在这个元素上声明的名称空间适用于声明它的元素和属性，以及该元素内容中的所有元素及其属性。xmlns:prefixname作为该元素的属性名，属性的值是一个URI引用，是标识该名称空间的名称空间名字。其中prefixname给出名称空间前缀的名字，该前缀用于将元素及属性的名字与URI关联在一起。需要注意的是，在这样的声明中，名称空间的名字不能为空("")。来自于XML名称空间的名字可以作为限定名(qualified names)出现，限定名包含了一个以冒号(:)分隔的名称空间前缀和一个本地部分(local part)。映射到URI引用的名称空间前缀选择了一个名称空间。名称空间前缀可以是不包含冒号的任何合法的XML名称，在声明名称空间时，有两个前缀是不允许使用的——xml和xmlns。
2. 第二种形式：<元素名 xmlns="URI">
这种声明形式没有给出名称空间的前缀名，URI所标识的是默认的名称空间。在这样的默认声明中，属性值可以为空("")。  
**在声明名称空间时，选择的URI不需要指向实际的内容，在URI所标识的位置上，可以不存在任何东西。在名称空间声明中的URI，只是形式上的标识符，其唯一的目的是提供一个唯一的名字**


##### 默认名称空间
我们可以使用没有前缀名的xmlns属性将默认的名称空间附加给元素及其子元素，元素本身及其子元素都被认为是在默认的名字空间中，除非它们有明确的前缀。默认名称空间声明中的URI可以设为空字符串，这样的话，在它的声明范围内，没有前缀的元素将被认为不存在于任何的名称空间中，这和没有声明默认名称空间时一样的。

##### 属性的名称空间
一个属性想要在某个名称空间中，必须给该属性加上名称空间的前缀，没有前缀的属性不在任何的名称空间中(包括默认的名称空间)。即使拥有属性的元素在某个名称空间中，没有前缀的属性仍然不在该名称空间或任何其他的名称空间中。

### XML Schema
基本概念：XML Schema是基于XML的 DTD替代者。XML Schema主要用来描述 XML文档的结构。XML Schema语言也称作 XML Schema定义(XML Schema Definition，XSD)。为什么说XML Schema是DTD的继任者有以下几点理由：
* XML Schema 可针对未来的需求进行扩展
* XML Schema 更完善，功能更强大
* XML Schema 基于 XML 编写
* XML Schema 支持数据类型
* XML Schema 支持命名空间
 

##### 什么是XML Schema
* 定义可出现在文档中的元素
* 定义可出现在文档中的属性
* 定义哪个元素是子元素
* 定义子元素的次序
* 定义子元素的数目
* 定义元素是否为空，或者是否可包含文本
* 定义元素和属性的数据类型
* 定义元素和属性的默认值以及固定值

##### 定义XML Schema
在一个XML Schema定义文档中，<schema>元素是每个XML Schema的根元素，而且<schema>元素可包含属性，一个schema声明往往看上去如以下定义范例：
```
<?xml version="1.0"?>
 
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
targetNamespace="http://www.w3school.com.cn"
xmlns="http://www.w3school.com.cn"
elementFormDefault="qualified">
 
 ...
 ...
</xs:schema>
```
首先定义了一个名称空间“http://www.w3.org/2001/XMLSchema”，并且使用该名称空间的前缀xs:来限定schema本身，表示schema中用到的元素和数据类型来自名称空间“http://www.w3.org/2001/XMLSchema”。使用targetNamespace属性来表示当前schema定义的元素来自名称空间“http://www.w3school.com.cn”。使用xmlns来定义默认的名称空间为“http://www.w3school.com.cn”。最后使用elementFormDefault表示在任何XML实例文档所使用的且在此schema中声明过的元素必须被名称空间限制。

##### 引用XML Schema
如下是一个XML文档引用XML Schema的例子：
```
<?xml version="1.0"?>

<note xmlns="http://www.w3school.com.cn"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.w3school.com.cn note.xsd">

    <to>George</to>
    <from>John</from>
    <heading>Reminder</heading>
    <body>Don't forget the meeting!</body>
</note>
```
xmlns定义了默认的名称空间为“http://www.w3school.com.cn”，并定义了一个前缀为xsi的名称空间“http://www.w3.org/2001/XMLSchema-instance”，使用xsi名称空间下的schemaLocation元素来指定使用xsd文件验证某个名称空间本例是使用相同路径下的note.xsd文件来验证“http://www.w3school.com.cn”名称空间。