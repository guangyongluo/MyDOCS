### XML简介
XML的全称是Extensible Markup Language,意思是可扩展的标记语言。它是标准通用标记语言(Standard Generalized Markup Language, SGML)的一个子集。它以一种开放的、自我描述的方式定义了数据结构。在描述数据内容的同时能突出对结构的描述，从而体现出数据与数据之间的关系。XML不能描述页面的排版和表现形式，它只是用于描述数据和数据的结构。也就是说，XML将数据和显示分开了，我们可以为这些数据设计不同的排版和表现形式，而数据本身不需要做任何的修改。采用XML来表示数据，我们能够很容易地读懂XML文档，而计算机也能够很好地进行识别和处理。XML表示数据的方式真正做到了独立与应用系统，并且数据能够重用，一份数据可以应用于不同的场合。有时候，XML文档也被看做是文档的数据库化和数据的文档化。

##### 为什么要学习XML
* XML是一种通用的数据交换格式；
* 许多系统的配置文件都使用XML格式；
* JSP文档也逐渐向XML语法格式过渡；
* 许多项目都采用XML作为数据交换格式；
* 在日常应用中会经常看到XML格式的文件；

##### XML对文档的格式要求严格
1. 开始标签必须要有一个结束标签配套；
2. 空元素标签必须被关闭；
3. 所有的标签都区别大小写；
4. 所有的标签都必须合理嵌套；
5. 所有标签的属性值必须用双引号（\" \"）或单引号(\' \')括起来；
6. XML有且只有一个根元素。

### XML文档
每一个XML文档都有一个逻辑结构和一个物理结构。物理上而言，文档由称为实体(entities)的存储单元组成，实体都具有内容并且都通过实体的名字进行标识(文档实体和外部DTD子集除外)。实体可以是一段文本、一个文件、一个数据库记录或其他包含数据的项目。一个实体可以引用其他的实体，从而将它们包含在文档中。文档开始于“根(root)”或文档实体(document entity)。格式良好的XML文档形成了一种层次树结构，而这个数的根就是文档实体，与其他实体不同，文档实体没有名字，只是用于表示文档树的根。XML文档的根元素被称为文档元素(document element)，它和在其外部出现的处理命令、注释等作为文档实体的子节点，而根元素本身和其内部的子元素也是一颗树。  
实体可以包含已分析(parsed)的或未分析的(unparsed)数据。已分析的数据由字符组成，其中一些字符组成字符数据，另一些字符组成标记。已分析的实体(parsed entity)内容被称为它的替换文本，这个文本被看成是文档整体的一部分。在XML处理器分析XML文档时，凡是文档中出现引用已分析实体的地方，都将被该实体的内容所替换。  
未分析的实体(unparsed entity)是一种资源，它的内容可以是也可以不是文本，并且，如果是文本的话，可以不是XML文本。每一个未分析的实体有一个相关联的用名字标识的记号(notation)。除了要求XML处理器能向引用程序提供可用的实体和记号的标识符之外，XML对未分析的实体内容不作任何限制。  
已分析的实体以实体引用的方式通过名字来调用；未分析的实体通过ENTITY或ENTITIES属性中给出的名字来调用。  
逻辑上而言，文档由声明、元素、注释、字符引用和处理指令组成，在文档中，所有这些都是通过显示地标记(markup)来指明的。  
XML标记(markup)包括开始标签(tag)、结束标签、空元素标签、实体引用、字符引用、注释、CDATA段定界符、文档类型声明、处理指令、XML声明、文本声明及任何在文档实体顶层的空白(在文档元素之外，且不在任何其他的标记内部)。其他所有非标记的文本组成文档的字符数据。  
XML文档在逻辑上主要由以下5个部分组成：
* XML声明；
* 文档类型声明；
* 元素；
* 注释；
* 处理指令。

##### XML声明
XML文档总是以一个XML声明开始，其中指明所用的XML版本、文档的编码、文档的独立性信息。其格式为：`<?xml version info [encoding info] [doc independence]?>`。文档编码声明默认是UTF-8，如果要用中文，可以在声明中加上`encoding="bg2312"`。如果文档不依赖于外部文档，可以在XML声明中加上`standalone="no"`来声明这个文档是独立的文档。**注意：XML声明必须位于文档的第一行，前面不能有任何字符。**

##### 文档类型声明
我们可以用DTD(Document Type Definition，文档类型定义)来规范XML文档。通过文档类型声明，指出XML文档所用的DTD。文档类型声明有两种形式，一种是声明DTD在一个外部的文件中，例如：`<!DOCTYPE greeting SYSTEM "hello.dtd"`另一种是直接在XML文档中给出DTD，例如：
```
<!DOCTYPE greeting [
    <!ELEMENT greeting (#PCDATA)
]>
```

##### 元素
在XML中，元素由开始标签、元素内容和结束标签构成。空元素则由空元素标签构成。每一个元素有一个用名字标识的类型，同时它可以有一个属性说明集，每一个属性说明有一个名字和一个值。给元素命名时，还需要遵守以下规范：
* 名称只能以字母、下划线(\_)开头；
* 名称中可以包含字母、数字、下划线及其他在XML标准中允许的字符；
* 名字不能包含空格；
* 名称中尽可能不要使用冒号(:)，因为冒号在名称空间中被用于分隔名称空间前缀和本地部分。

元素的类型：
* 空元素 `<student/>`
* 带有属性的空元素`<student name="张三" age="18"/>`
* 带有内容的元素：
```
<students>
    <student>
        <name>张三</name>
        <age>18</age>
    </student>
</students>
```

元素内容的类型：
* 子元素：子元素本身也是元素，被嵌套在上层元素之内；
* 字符数据：在一个元素内容中，字符数据可以是不包含任何标记的起始定界符和CDATA段的结束定界符的任意字符串，也就是说在元素的内容中，字符数据不能有和号(&)和小于号(<)，也不能有字符串“]]>”。在CDATA段中，字符数据可以是不包括CDATA段的结束定界符的任意字符串。
* 字符引用和预定义实体引用：在XML中，提供了5个预定义的实体引用，如下表：  

|字符|字符引用(十进制代码)|字符引用(十六进制代码)|预定义实体引用|
|:----:|:------:|:------:|:----:|
|<|`&#60;`|`&#x3c;`|`&lt;`|
|>|`&#62;`|`&#x3e;`|`&gt;`|
|"|`&#34;`|`&#x22;`|`&quot;`|
|'|`&#39;`|`&#x27;`|`&apos;`|
|&|`&#38;`|`&#x26;`|`&amp;`|

* CDATA段：CDATA段中包含的都是纯字符数据，在字符数据可以出现的任何地方都可以使用CDATA段。CDATA段主要用于需要将整个文本解释为字符数据。CDATA段中的内容不被XML处理器分析，所以可以在其中包含任意的字符。CDATA段以字符串“<!\[CDATA\[”开始，以字符串“]]>”结束。

##### 属性
* 一个标签可以有多个属性，每个属性都有它自己的名称和取值；
* 属性值一定要用双引号(")或者单引号(')引起来；
* 属性遵循与标签相同的命名规范；
* 属性可以被改成用子元素来描述同样的信息。

##### 注释
XML、HTML的注释都是以`<!--`开头，以`-->`结尾的形式标注一些解释说明的文字，位于注释之间的数据将被XML处理忽略。需要注意以下五点信息：
1. 注释不能出现在XML声明之前，XML声明必须是文档最前面的部分；
2. 注释不能出现在标记中；
3. 注释可以包围和隐藏标记，但要注意的是，在注释掉标记之后，要保证剩余的文本仍然是一个结构完整的XML文档；
4. 字符串“--”不能再注释中出现；
5. 在XML中不允许注释以“--->”结尾。

##### 处理命令
处理命令(processing Instructions, PI)允许文档中包含由应用程序来处理的指令。在XML文档中，有可能会包含一些非XML格式的数据，这些数据XML处理器无法处理，我们就可以通过处理指令来通知其他应用程序来处理这些数据。例如使用样式表单的处理指令：`<?xml-stylesheet href="hello.css" type="text/css"?>`。xml-stylesheet处理指令总是放在XML声明之后，第一个元素之前。其他的处理指令可以放在除标记的内部和XML声明之前的任何位置。要注意，虽然XML声明和处理指令的语法形式相似，但XML声明并不是处理指令，XML处理程序对XML声明和处理指令采取的是不同的处理方式。

##### 空白和换行的处理
对于XML中的标签以外的所有空格和换行，XML解析程序都要一个个如实地交给下游程序去处理，XML处理器总是将文档中不是标记的所有字符都传递给应用程序，一个进行有效性验证的XML处理器会通知应用程序这些字符中的哪一些组成了出现在元素内容中的空白。当在元素中可以用特殊的属性xml:space来通知应用程序保留此元素中的空白。它的值必须是default和preserve两者之一，也可以两个都取。


##### 行尾处理
在XML空白字符中，有两个是标准的ASCII码行尾控制符：回车(CR,#xA)和换行(LF,#xD)。在Windows平台下，采用#xD#xA的组合作为行分隔符，而Linux、Unix系统则采用#xA作为行分隔符，在Mac OS下，采用#xD作为行分隔符。为了简化应用程序的工作，XML处理器在解析之前，要将所有的两字符序列#xD#xA，以及单字符#xD转换成单个的#xA字符。

##### 格式良好的(Well-formed)XML
计算机程序在处理XML文档之前，首先必须能够解析出XML文档内容中的各个元素的相关信息。用于解析XML文档的解析器程序对应的英文术语叫Parser。要让计算机程序解析出XML文档内容所表述的信息，XML文档更应该严格遵循一定的语法。遵守XML基本语法规则和规范的XML文档就可以称之为“Well-formed XML”，中文意思就是“格式良好的XML”。

##### XML的约束模式
约束模式定义了XML文档中允许出现的元素名(也就是标记名)、元素中的属性、元素中的内容类型以及元素之间的嵌套关系和出现顺序。XML约束模式不仅定义了XML文档的词汇表，它还定义了一个XML文档必须遵循什么样的结构。如果把一个XML文件看作是数据库中的一个表，那么XML约束就相当于数据库表结构的定义。如果没有为一个XML文档指定约束模式，那么该文档中可以包含任何类型的标记；如果为一个XML文档指定了约束模式，那么它必须满足约束模式所规定的结构、数据类型和数据关联等内容。

##### XML的约束模式语言
用作XML约束模式的内容也需要遵循一定的语法规则，这些语法规则就形成了XML约束模式语言。XML约束模式语言是用来创造XML标记语言的语言，这种用于定义另一种语言的语言被称为元语言。约束模式通常都是在一个单独的文件中进行定义，这个文件被称作模式文档。与模式文档的概念相对应，依照模式文档编写的XML文档被称为实例文档。先后出现的XML约束模式语言有XML DTD、XDR、SOX、XML Schema等等，其中应用最广泛和最具有代表意义的是XML DTD和XML Schema。

##### 有效的(valid)XML
一个遵守XML的基本语法规则、且符合为它指定的某个XML约束模式的XML文档就可以称之为“Valid XML”文档，中文意思就是“有效的XML”文档。一个XML文档并不一定需要是有效的，但必须是格式良好的。将一个XML文档和它所引用的XML约束模式进行比较分析，看其中的内容是否符合XML约束的过程叫校验(validation)，校验过程也是通过解析器程序软件(Parser)来处理的。根据能否对XML文档进行约束模式校验，可以将XML解析器分为两类：非校验类解析器和校验类解析器。

##### 语言标识
在文档处理中还可以使用一个特殊的元素属性xml:lang来指出XML文档中任何元素的内容和属性的值所使用的语言。

### XML名称空间
XML名称空间的概念是通过给元素或属性加上一个名称空间，来唯一标识一个元素或属性。名称空间通过使用一系列的保留属性来声明，这种属性的名字必须是以xmlns或以xmlns:作为前缀。与其他任何XML属性一样，这些属性可以直接或以默认的方式给出。有以下两种形式的名称空间声明：
1. 第一种形式：<元素名 xmlns:prefixname="URI">
元素名是指在哪一个元素上声明名称空间，在这个元素上声明的名称空间适用于声明它的元素和属性，以及该元素内容中的所有元素及其属性。xmlns:prefixname作为该元素的属性名，属性的值是一个URI引用，是标识该名称空间的名称空间名字。其中prefixname给出名称空间前缀的名字，该前缀用于将元素及属性的名字与URI关联在一起。需要注意的是，在这样的声明中，名称空间的名字不能为空("")。来自于XML名称空间的名字可以作为限定名(qualified names)出现，限定名包含了一个以冒号(:)分隔的名称空间前缀和一个本地部分(local part)。映射到URI引用的名称空间前缀选择了一个名称空间。名称空间前缀可以是不包含冒号的任何合法的XML名称，在声明名称空间时，有两个前缀是不允许使用的——xml和xmlns。
2. 第二种形式：<元素名 xmlns="URI">
这种声明形式没有给出名称空间的前缀名，URI所标识的是默认的名称空间。在这样的默认声明中，属性值可以为空("")。  
**在声明名称空间时，选择的URI不需要指向实际的内容，在URI所标识的位置上，可以不存在任何东西。在名称空间声明中的URI，只是形式上的标识符，其唯一的目的是提供一个唯一的名字**


##### 默认名称空间
我们可以使用没有前缀名的xmlns属性将默认的名称空间附加给元素及其子元素，元素本身及其子元素都被认为是在默认的名字空间中，除非它们有明确的前缀。默认名称空间声明中的URI可以设为空字符串，这样的话，在它的声明范围内，没有前缀的元素将被认为不存在于任何的名称空间中，这和没有声明默认名称空间时一样的。

##### 属性的名称空间
一个属性想要在某个名称空间中，必须给该属性加上名称空间的前缀，没有前缀的属性不在任何的名称空间中(包括默认的名称空间)。即使拥有属性的元素在某个名称空间中，没有前缀的属性仍然不在该名称空间或任何其他的名称空间中。

