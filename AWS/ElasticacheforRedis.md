### Elasticache for Redis

##### 缓存策略模式

- Cache Aside(旁路缓存)：应用程序发出写请求后直接将key从cache中删除，然后由数据库驱动cache的更新，简单步骤是先更新DB再从缓存中删除key值。对于读请求是先读cache，如果cache没有再读DB同时将DB中的数据回写cache再返回给应用程序；这种策略的特点是应用程序处理所有数据访问细节，并利用Lasy计算的思想更新DB时直接删除cache，最后通过DB数据驱动更新，以确保数据以DB结果为准，可以大幅降低数据库和Cache不一致的概率。所以如果业务需求对缓存一致性较高，或者缓存数据更新比较复杂的业务都可以使用Cache Aside(旁路缓存策略模式)；
- Read/Write through(读写穿透)：在Cache Aside的策略模式中，应用程序需要同时维护两个数据端，过于繁琐，于是就出现了Read/Write through(读写穿透)策略模式。在这种模式中，业务应用只需要关注存储服务即可，应用的读写Cache和DB的操作都由存储服务代理。存储服务接到业务应用的写请求时，会首先查看Cache，如果数据在Cache中不存在再去更新DB，如果数据在Cache中存在则先更新Cache然后再去更新DB，而储存服务收到读请求时，如果命中Cache则直接返回，否则先从DB中加载再回写Cache后返回响应。这种策略模式的特点是存储服务封装了所有的读写请求的逻辑，业务代码只关注业务逻辑，使系统的隔离性更加，另外进行写操作时如果Cache没有数据则不更新，有数据才更新内存效率更高。
- Read Behind Cache(缓存读写)：Read Behind Cache策略模式和Read/Write through策略模式一致也由存储服务来管理Cache和DB的读写，不同点是Read/Write through是同步更新缓存和DB，而Read Behind Cache采用异步批量的方式来更新DB，这种策略模式非常适合更新特别频繁的业务，但这种模式有个显著的特点即数据一致性变差，甚至在极端情况下有丢数据的风险。这种策略模式非常适合变更频率非常高但对数据一致性要求不高的业务。

##### 缓存的架构设计

- 缓存组件选择：memcache和Redis对比；
- 数据结构设计：对于简单的K-V结构的数据，你可以将数据类型设计成String，JSON或者Protocol Buffer等格式，对于需要计算的数据则需要设计成Hash，Set，List等格式；
- 缓存分布：取摸、Hash一致性算法；

##### 缓存的经典问题

- 缓存失效：大量的key值同时失效将导致查询请求直接打到DB，DB压力增大慢查询变多，为了避免大量Key同时失效，在设置TTL时使用base+random的做法可以有效避免大量key同时失效问题；
- 缓存穿透：大量对不存在的key发送读请求会导致缓存穿透问题，这些对不存在的key值的请求将直接打到DB上导致DB负载过大。有两种思路解决这个问题，1.当查到不存在的key值时也回写Cache只是使用一个特殊的value来表示该Key不存在，当下次再查询这个key值时从缓存直接返回null，同时设置TTL让这个特殊的value在一定的时间后过期。2.构建一个BloomFilter来过滤查询请求，使用BloomFilter来记录全量Key，当查询到不存在的key就直接返回。
- 缓存雪崩：缓存雪崩是指部分缓存节点不可用导致整个系统不可用的情况。

​																																																																																																																																														