### JavaScript 原型链和继承

###### JavaScript的原型对象
每个JavaScript的对象(null除外)都和另一个对象相关联。这个对象就是我们熟知的原型，每个对象都从原型继承属性。所有通过字面
量创建的对象都具有同一个原型对象，并可以通过JavaScript代码Object.prototype获得对原型对象的引用。通过关键字new和构造函数
调用创建的对象的原型对象就是构造函数的prototype属性的值。这个属性的值是一个对象，唯一一个不可枚举属性constructor。
constructor属性值是一个函数对象。如下代码演示了函数的prototype属性和原型对象属性constructor的关系：
```
var F = function(){}; //这是一个函数对象
var p = F.prototype; //这是F相关的原型对象
var c = p.constructor; //这是与原型相关联的函数
c === F; // => true: 对于任意函数F.prototype.constructor==F
```

###### JavaScript构造函数
在JavaScript中任何函数都是一个可执行的对象，可以为其定义属性和方法。使用function关键字定义函数语句`functiong f(){}`。
在默认情况下JavaScript的构造函数名首字母大写，使用`new`关键字调用函数的方式就可以返回一个对象，所以在JavaScript中凡是
使用`new`关键字调用的函数都是构造函数，更准确的说**没有构造函数只有构造调用**。JavaScript的函数都有一个原型对象使用
prototype属性指定，当调用函数时这个原型对象就自动生成并使用prototype属性引用。形象的理解构造函数的执行如下代码：
```
function F(){
    console.log("构造函数");
}

/*
当调用 var fun = F()时有如下几个关键步骤：
1. var obj = {};
2. obj.__proto__ = F.prototype;
3. F.call(obj);
4. return obj;
*/
```
从以上代码来看JavaScript的构造函数主要的作用其实就是放回新对象的初始化动作。作为构造函数调用最重要的一步就是第二步，
将新生成的对象的__proto__属性赋值为构造函数的prototype属性，使得通过构造函数创建的所有对象可以共享相同的原型。这意味
着同一个构造函数创建的所有对象都是继承自一个相同的对象，因此它们都是同一个类的对象。调用构造函数的一个重要特征是，构
造函数的prototype属性被用做新对象的原型。这意味着通过同一个构造函数创建的所有对象都继承自一个相同的对象，因此它们都是
同一个类的成员。

###### 构造函数和类的标识
原型对象是类的唯一标识：当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例。而初始化对象的状态的构造
函数则不能作为类的标识，两个构造函数的prototype属性可能指向同一个原型对象。那么这两个构造函数创建的实例是属于同一个类
的。尽管构造函数不像原型那样基础，但构造函数是类的“外在表现”。构造函数的名字通常可以用来作为类名。当使用instanceof
运算符来检测对象是否属于某个类时会用到构造函数。实际上instanceof运算符并不会检查某个对象是否是由构造函数初始化来的，
而会检查某个对象是否继承自这个构造函数的prototype属性。

###### JavaScript原型链
JavaScript对象具有“自有属性”(own property)，也有一些属性是从原型对象继承而来的。为了更好地理解这种继承，必须更深入
地了解属性访问的细节。假设要查询对象o的属性x，如果o中不存在x，那么将会继续在o的原型对象中查询属性x。如果原型对象中也
没有x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x或者查找到一个原型是null的对象为止。
可以看到对象的原型属性构成了一个“链”,通过这个“链”可以实现属性的继承。