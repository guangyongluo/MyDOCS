### Web前后端缓存技术
在一个Web应用中，应用到缓存的地方有很多，主要有浏览器缓存，页面缓存，服务器缓存，数据库缓存等。缓存的作用主要有：
* 加快页面打开速度
* 减少网络带宽消耗
* 降低服务器压力

###### 浏览器缓存
浏览器端缓存规则主要在HTTP协议头和HTML的meta标签中定义。他们分别从新鲜度和校验值两个维度来规定浏览器是否可以直接使用缓存
中的副本，还是需要去源服务器获取更新的版本。
1. 新鲜度（过期机制）：也就是缓存副本有效期。一个缓存副本必须满足以下条件，浏览器会认为它是有效的，足够新的：
* 含有完整的过期时间控制头信息（HTTP协议报头），并且仍在有效期内；
* 浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度
满足以上两个情况的一种，浏览器会直接从缓存中获取副本并渲染
2. 校验值（验证机制）：服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag（Entity Tag），它可以用来作为浏览
器再次请求过程的校验标识。如果发现校验标识不匹配，说明资源已经被修改或过期，浏览器需求重新获取资源内容。

使用HTML Meta 标签，Web开发者可以在HTML页面的<head>节点中加入<meta>标签，代码如下：`<META HTTP-EQUIV="Pragma" CONTENT=
"no-cache">`上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器取。使用上很简单，但只有部分浏览器可以支持
，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。而广泛应用的还是 HTTP头信息来控制缓存。

在HTTP请求和响应的消息报头中，常见的与缓存有关的消息报头有：

|规则|消息报头|值/示例|类型|作用|
|:----:|:--------:|:---------:|:----:|:----------------:|
|新鲜度|Expires|Mon, 13 Aug 2018 03:15:33 GMT|响应|告诉浏览器在过期时间前可以使用副本(有可能存在时间不一致问题)|
||Pragma|no-cache|响应|告诉浏览器忽略资源的缓存副本(HTTP1.1可用Cache-Control替换)|
||Cache-Control|no-cache|响应|告诉浏览器忽略资源的缓存副本，强制每次请求直接发送给源服务器|
|||no-store|响应|强制缓存在任何情况下都不要保留任何副本|
|||max-age=[second]|响应|指明缓存副本的有效时长，从请求时间开始到过期时间之间的秒数|
|||public|响应|任何途径的缓存者(本地缓存，代理服务器)，可以无条件的缓存该资源|
|||private|响应|只针对单个用户或实体(不同用户，窗口)缓存资源|
||Last-Modified|Mon, 13 Aug 2018 03:15:33 GMT|响应|告诉浏览器当前资源的最后修改时间|
||If-Modified-Since|Mon, 13 Aug 2018 03:15:33 GMT|请求|如果浏览器第一次请求时响应中Last-Modified非空，第二次请求同一资
源时，会把它作为该项的值发给服务器|
|校验值|ETag|50b1c1d4f775c61:df3|响应|告诉浏览器当前资源在服务器的唯一标识符(生成规则有服务器决定)|
||If-None-Match|50b1c1d4f775c61:df3|请求|如果浏览器第一次请求时响应中ETag非空，第二次请求同一资源时，会把它作为该项的值
发送给服务器|
|辅助|Vary|Accept-Encoding|响应|辅助从多个缓存副本中筛选合适的版本(不同压缩算法产生的副本)|

###### HTTP缓存机制
缓存行为主要由缓存策略决定，而缓存策略由内容拥有者设置。这些策略主要通过特定的HTTP头部来清晰地表达。当一个用户发起一个静
态资源请求的时候，浏览器会通过以下几步来获取资源：
* 本地缓存阶段：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送http请求到服务
器；
* 协商缓存阶段：如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个http请求到服务器,然后服务器
判断这个请求，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源；
* 缓存失败阶段：当服务器发现请求的资源已经修改过，或者这是一个新的请求(在本来没有找到资源)，服务器则返回该资源的数据，并
且返回200， 当然这个是指找到资源的情况下，如果服务器上没有这个资源，则返回404。

###### 本地缓存阶段
1. Expires：指定缓存到期GMT的绝对时间，如果设了max-age，max-age就会覆盖expires。如果expires到期需要重新请求。
2. Cache-Control是http 1.1中为了弥补 Expires 缺陷新加入的。对已缓存的内容进行控制：
3. Cache-control: public表示缓存的版本可以被代理服务器或者其他中间服务器识别。
4. Cache-control: private意味着这个文件对不同的用户是不同的。只有用户自己的浏览器能够进行缓存，公共的代理服务器不允许缓存。
5. Cache-control: no-cache意味着文件的内容不应当被缓存。这在搜索或者翻页结果中非常有用，因为同样的URL，对应的内容会发生变化。
**Cache-control其他相关控制字段**
* max-age: 指定缓存过期的相对时间秒数，max-ag=0或者是负值，浏览器会在对应的缓存中把Expires设置为1970-01-01 08:00:00。
* s-maxage: 类似于max-age，只用在共享缓存上，比如proxy。
* public: 通常情况下需要http身份验证的情况，响应是不可cahce的，加上public可以使它被cache。
* no-cache: 强制浏览器在使用cache拷贝之前先提交一个http请求到源服务器进行确认。这对身份验证来说是非常有用的,能比较好的遵
守 (可以结合public进行考虑)。它对维持一个资源总是最新的也很有用，与此同时还不完全丧失cache带来的好处)，因为它在本地是有拷
贝的，但是在用之前都进行了确认，这样http请求并未减少，但可能会减少一个响应体。
* no-store: 告诉浏览器在任何情况下都不要进行cache，不在本地保留拷贝。
* must-revalidate: 强制浏览器严格遵守你设置的cache规则。
* proxy-revalidate: 强制proxy严格遵守你设置的cache规则。
* cache：使用本地缓存，不发生请求。

###### 协商缓存阶段
1. Last-Modified & if-modified-since：Last-Modified与If-Modified-Since是一对报文头，属于http 1.0。 last-modified是WEB服
务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间。

2. ETag & If-None-Match：ETag与If-None-Match是一对报文，属于http 1.1。ETag可以用来解决这种问题。ETag是一个文件的唯一标
志符。就像一个哈希或者指纹，每个文件都有一个单独的标志，只要这个文件发生了改变，这个标志就会发生变化。ETag机制类似于乐
观锁机制，如果请求报文的ETag与服务器的不一致，则表示该资源已经被修改过，需要发最新的内容给浏览器。同时使用这两个报文头，
在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，如都与服务器的相符，服务器返回304，否则，发送最
新内容给浏览器。

Etag/lastModified过程如下：

客户端请求一个页面（A）。服务器返回页面A，并在给A加上一个Last-Modified/ETag。客户端展现该页面，并将页面连同Last-Modified
/ETag一起缓存。客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。服务器检查该Last-Modified
或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。304：通过If-Modified-Since If-Match
判断资源是否修改，如未修改则返回304，发生了一次请求，但请求内容长度为0，节省了带宽。 如果有多台负载均衡的服务器，不同服
务器计算出的Etag可能不同，这样就会造成资源的重复加载。

Etag 主要为了解决 Last-Modified 无法解决的一些问题：
1. 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，
而重新GET；
2. 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这
种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
3. 某些服务器不能精确的得到文件的最后修改时间。

###### Web离线应用
让Web应用能够实现“本地安装”的目的是保证它们能够在离线状态下依然能够访问。将自己“安装”到应用程序缓存中的Web应用，在离
线状态下使用localStorage来保存应用相关的数据，同时还具备一套同步机制，在再次回到在线状态的时候，能够将储存的数据传输给服
务器。