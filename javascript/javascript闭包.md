### Javascript闭包

在讨论ECMAScript闭包之前，先来介绍下函数式编程中一些基本定义。 然而，为了更好的解释这些定义，这里还是拿ECMAScript来举例。
众所周知，在函数式语言中（ECMAScript也支持这种风格），函数即是数据。就比方说，函数可以保存在变量中，可以当参数传递给其他
函数，还可以当返回值返回等等。 这类函数有特殊的名字和结构。  

在面向堆栈的编程语言中，函数的本地变量都是保存在堆栈上的， 每当函数激活的时候，这些变量和函数参数都会压栈到该堆栈上。当
函数返回的时候，这些参数又会从堆栈中移除。这种模型对将函数作为函数式值使用的时候有很大的限制（比方说，作为返回值从父函数
中返回）。 绝大部分情况下，问题会出现在当函数有自由变量的时候。自由变量是指在函数中使用的，但既不是函数参数也不是函数的
局部变量的变量。如下所示：

```
function testFn() {

        var localVar = 10;

        function innerFn(innerParam) {
            alert(innerParam + localVar);
        }

        return innerFn;
    }

    var someFn = testFn();
    someFn(20); // 30
```  

上述例子中，对于innerFn函数来说，localVar就属于自由变量。对于采用面向堆栈模型来存储局部变量的系统而言，就意味着当testFn
函数调用结束后，其局部变量都会从堆栈中移除。这样一来，当从外部对innerFn进行函数调用的时候，就会发生错误（因为localVar变
量已经不存在了）。而且，上述例子在面向堆栈实现模型中，要想将innerFn以返回值返回根本是不可能的。 因为它也是testFn函数的局
部变量，也会随着testFn的返回而移除。  

还有一个函数对象问题和当系统采用动态作用域，函数作为函数参数使用的时候有关。看如下例子：
```
    var z = 10;

    function foo() {
        alert(z);
    }

    foo(); // 10 – 静态作用域和动态作用域情况下都是

    (function () {

        var z = 20;
        foo(); // 10 – 静态作用域情况下, 20 – 动态作用域情况下

    })();

    // 将foo函数以参数传递情况也是一样的

    (function (funArg) {

        var z = 30;
        funArg(); // 10 – 静态作用域情况下, 30 – 动态作用域情况下

    })(foo);
```
我们看到，采用动态作用域，变量（标识符）处理是通过动态堆栈来管理的。因此，自由变量是在当前活跃的动态链中查询的，而不是在
函数创建的时候保存起来的静态作用域链中查询的。这样就会产生冲突。比方说，即使Z仍然存在（与之前从堆栈中移除变量的例子相反）
，还是会有这样一个问题： 在不同的函数调用中，Z的值到底取哪个呢（从哪个上下文，哪个作用域中查询）？

上述描述的就是两类funArg问题——取决于是否将函数以返回值返回（第一类问题）以及是否将函数当函数参数使用（第二类问题）。为
了解决上述问题，就引入了闭包的概念。下面重点来了，闭包的面纱就此揭开。

对于采用面向堆栈模型来存储局部变量的系统而言，就意味着当testFn函数调用结束后，其局部变量都会从堆栈中移除。 这样一来，当
从外部对innerFn进行函数调用的时候，就会发生错误（因为localVar变量已经不存在了）。而且，上述例子在面向堆栈实现模型中，要
想将innerFn以返回值返回根本是不可能的。 因为它也是testFn函数的局部变量，也会随着testFn的返回而移除。

闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一
部分。闭包的特点：
1. 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。
2. 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。
简单的说，Javascript允许使用内部函数---即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所
在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就
会形成闭包。闭包是代码块和创建该代码块的上下文中数据的结合。 让我们来看下面这个例子：

```
    var x = 20;

    function foo() {
        alert(x); // 自由变量 "x" == 20
    }

    // foo的闭包
    fooClosure = {
        call: foo // 对函数的引用
        lexicalEnvironment: {x: 20} // 查询自由变量的上下文
    };
``` 
上述例子中，“fooClosure”部分是伪代码。对应的，在ECMAScript中，“foo”函数已经有了一个内部属性——创建该函数上下文的作
用域链。这里“lexical”是不言而喻的，通常是省略的。上述例子中是为了强调在闭包创建的同时，上下文的数据就会保存起来。当下
次调用该函数的时候，自由变量就可以在保存的（闭包）上下文中找到了，正如上述代码所示，变量“z”的值总是10。  

定义中我们使用的比较广义的词——“代码块”，然而，通常（在ECMAScript中）会使用我们经常用到的函数。 当然了，并不是所有对
闭包的实现都会将闭包和函数绑在一起，比方说，在Ruby语言中，闭包就有可能是：一个程序对象（procedure object）, 一个lambda表
达式或者是代码块。对于要实现将局部变量在上下文销毁后仍然保存下来，基于堆栈的实现显然是不适用的（因为与基于堆栈的结构相矛
盾）。因此在这种情况下，上层作用域的闭包数据是通过动态分配内存的方式来实现的（基于“堆”的实现），配合使用垃圾回收器（
garbage collector简称GC）和引用计数（reference counting）。 这种实现方式比基于堆栈的实现性能要低，然而，任何一种实现总是
可以优化的：可以分析函数是否使用了自由变量，函数式参数或者函数式值，然后根据情况来决定——是将数据存放在堆栈中还是堆中。


###### JavaScript作用域
先来谈谈变量的作用域，变量的作用域无非就是两种：全局变量和局部变量。 
全局作用域： 最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的
```
var outerVar = "outer";
function fn(){
 console.log(outerVar);
}
fn();//result:outer
```
局部作用域：和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的，最常见的例如函数内
部
```
function fn(){
    var innerVar = "inner";
}
fn();
console.log(innerVar);// ReferenceError: innerVar is not defined
```
***需要注意的是，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！***
```
function fn(){
    innerVar = "inner";
}
fn();
console.log(innerVar);// result:inner
```
再来看一个代码：
```
var scope = "global";
function fn(){
    console.log(scope);//result:undefined
    var scope = "local";
    console.log(scope);//result:local;
}
fn();
```
很有趣吧，第一个输出居然是undefined，原本以为它会访问外部的全局变量(scope="global")，但是并没有。这可以算是javascript的
一个特点，只要函数内定义了一个局部变量，函数在解析的时候都会将这个变量“提前声明”,上个例子在JavaScript中可以表述成一下
代码所示：
```
var scope = "global";
function fn(){
    var scope;//提前声明了局部变量
    console.log(scope);//result:undefined
    scope = "local";
    console.log(scope);//result:local;
}
fn();
```
然而，也不能因此草率地将局部作用域定义为：用var声明的变量作用范围起止于花括号之间。javascript并没有块级作用域，那什么是
块级作用域？ 像在C/C++中，花括号内中的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的。但是
javascript不同，并没有所谓的块级作用域，javascript的作用域是相对函数而言的，可以称为函数作用域。

###### JavaScript作用域链(Scope Chain)
那什么是作用域链？ 我的理解就是，根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问。
想要知道js怎么链式查找，就得先了解js的执行环境。  

执行环境（execution context）：每个函数运行时都会产生一个执行环境，而这个执行环境怎么表示呢？js为每一个执行环境关联了一
个变量对象。环境中定义的所有变量和函数都保存在这个对象中。全局执行环境是最外围的执行环境，全局执行环境被认为是window对象
，因此所有的全局变量和函数都作为window对象的属性和方法创建的。js的执行顺序是根据函数的调用来决定的，当一个函数被调用时，
该函数环境的变量对象就被压入一个环境栈中。而在函数执行之后，栈将该函数的变量对象弹出，把控制权交给之前的执行环境变量对象
。举个例子：
```
var scope = "global"; 
function fn1(){
    return scope; 
}
function fn2(){
    return scope;
}
fn1();
fn2();
``` 
上面代码执行情况演示：
![图1-1][javascript_scope_01]


了解了环境变量，再详细讲讲作用域链。当某个函数第一次被调用时，就会创建一个执行环境(execution context)以及相应的作用域链，
并把作用域链赋值给一个特殊的内部属性([scope])。然后使用this，arguments(arguments在全局环境中不存在)和其他命名参数的值来
初始化函数的活动对象(activation object)。当前执行环境的变量对象始终在作用域链的第0位。以上面的代码为例，当第一次调用fn1
()时的作用域链如下图所示： 
![图1-2][javascript_scope_02]
可以看到fn1活动对象里并没有scope变量，于是沿着作用域链(scope chain)向后寻找，结果在全局变量对象里找到了scope，所以就返回
全局变量对象里的scope值。

那作用域链地作用仅仅只是为了搜索标识符吗？再来看一段代码：
```
function outer(){
    var scope = "outer";
    function inner(){
        return scope;
     }
     return inner;
}
var fn = outer();
fn();
```
outer()内部返回了一个inner函数，当调用outer时，inner函数的作用域链就已经被初始化了（复制父函数的作用域链，再在前端插入自
己的活动对象），具体如下图：
![图1-3][javascript_scope_03]

一般来说，当某个环境中的所有代码执行完毕后，该环境被销毁（弹出环境栈），保存在其中的所有变量和函数也随之销毁（全局执行环
境变量直到应用程序退出，如网页关闭才会被销毁）但是像上面那种有内部函数的又有所不同，当outer()函数执行结束，执行环境被销
毁，但是其关联的活动对象并没有随之销毁，而是一直存在于内存中，因为该活动对象被其内部函数的作用域链所引用。具体如下图：
![图1-4][javascript_scope_04]
outer执行结束内部函数开始被调用，outer执行环境等待被回收，outer的作用域链对全局变量对象和outer的活动对象引用都断了，像上
面这种内部函数的作用域链仍然保持着对父函数活动对象的引用，就是闭包(closure)。

###### JavaScript内部属性[[scope]]与作用域链及其性能问题
大家都知道，函数是特殊的可执行对象既然是对象，就可以拥有属性 ，函数中存在这一个内部属性[[Scope]]（我们不能使用，供js引
擎使用） ，函数被创建时，这个内部属性就会包含函数被创建的作用域中对象的集合这个集合呈链式链接，被称为函数的作用域链 
作用域链上的每一个对象被称为可变对象（Variable Obejct）， 每一个可变对象都以键值对形式存在，举一个例子，看下面的全局函数
```
var a = 1;
function foo(){
    ...
}
```
foo函数创建时，它的作用域链中插入了一个全局对象GO（Global Object），包含全局所有定义的变量
```
// 伪代码
foo.[[Scope]] = {
    GO: {
        this: window ,
        window: ... ,
        document: ... ,
        ......
        a: undefined, // 预编译阶段还不知道a值是多少
        foo: function(){...},
    }
}

```
在函数执行时，会创建一个叫做执行环境/执行上下文（execution context）的内部对象，它定义了一个函数执行时的环境，函数每次执
行时的执行环境独一无二，多次调用函数就多次创建执行环境，并且函数执行完毕后，执行环境就会被销毁，执行环境有自己的作用域链
，用于解析标识符。看到这里可能大家有点蒙，我再给大家说明一下我的理解：[[Scope]]和执行期上下文虽然保存的都是作用域链，但
不是同一个东西，现在先明确一点区别，[[Scope]]属性是函数创建时产生的，会一直存在。而执行上下文在函数执行时产生，函数执行
结束便会销毁。


###### JavaScript闭包的实现
讨论完理论部分，接下来让我们来介绍下ECMAScript中闭包究竟是如何实现的。 这里还是有必要再次强调下：ECMAScript只使用静态
（词法）作用域（而诸如Perl这样的语言，既可以使用静态作用域也可以使用动态作用域进行变量声明）。
```
    var x = 10;

    function foo() {
        alert(x);
    }

    (function (funArg) {

        var x = 20;

        // funArg的变量 "x" 是静态保存的，在该函数创建的时候就保存了

        funArg(); // 10, 而不是 20

    })(foo);
```

[javascript_scope_01]: ../image/javascript_scope_01.png "图1-1"
[javascript_scope_02]: ../image/javascript_scope_02.png "图1-2"
[javascript_scope_03]: ../image/javascript_scope_03.png "图1-3"
[javascript_scope_04]: ../image/javascript_scope_04.png "图1-4"