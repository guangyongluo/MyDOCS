OOP:
1.简单介绍一下SOLID原则 -> 面向对象设计模式SOLID原则 1.单一责任原则(SRP):表明一个类有且只有一个职责。 2.开放关闭原则(OCP):一个类应该对扩展开放，对修改关闭。这意味着一旦创建了一个类并且应用程序的其他部分开始使用它，就不应该修改它。 3.里氏替换原则(LSP): 派生的子类应该是可替换基类的，也就是说任何类可以出现的地方，子类一定可以出现。值得注意的是，当通过继承实现多态行为时，如果派生类没有遵守LSP，可能会让系统引发异常。 4.接口隔离原则(ISP):表明类不应该被迫依赖他们不使用的方法，也就是说一个接口应该拥有尽可能少的行为，它是精简的，也是单一的。 5. 依赖倒置原则(DIP): 表明高层模块不应该依赖底层模块，相反，他们应该依赖抽象类或者接口。这意味着不应该在高层模块中使用具体的底层模块。

展开讲讲这些原则:
1. 单一职责原则(Single Responsibility Principle): 这个原则主要是让类的职责更加单一，每个类只需要负责自己的那部分，类的负责度就会降低。如果职责划分得很清楚，那么代码维护起来也更加容易。试想如果所有的功能都放在一个类中，那么这个类就会变得非常臃肿，改动一个地方可能改变整个代码结构，想想都非常可怕。当然，这个原则不仅仅使用于类，对于接口和方法也适用，即一个接口/方法，只负责一件事，这样的话，接口就会变得简单，方法中的代码会更少，易读，便于维护。
单一职责原则的好处：1).代码的颗粒度降低了，类的复杂度降低了；2).可读性提高了，每个类的职责都很明确，可读性自然更好；3).可维护性提高了，可读性提高了。一旦出现bug，自然更容易找到问题所在；4).改动源码消耗的资源降低了，更改的风险也降低了。
2. 开闭原则(Open Close Principle): 一个软件实体， 如类、模块和函数应该对扩展开放，对修改关闭。在软件的生命周期内，因为变化，升级和维护等原因需要对软件原有代码进行修改，可能会给旧代码引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现。开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统，开闭原则只定义了对修改关闭，对扩展开放。 其实只要遵循SOLID中的另外5个原则， 设计出来的软件就是符合开闭原则的。
3. 里氏替换原则(Liskov Substitution Principle): 所有引用基类的地方必须透明地使用其子类的对象。里氏替换原则对继承进行了规则上的约束1).子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象(已实现)方法; 2).子类中可以增加自己特有的方法; 3).当子类覆盖或实现父类的方法时，方法的前置条件(即方法的形参)要比父类方法的输入参数更宽松。(即只能重载不能重写); 4).当子类的方法实现父类的抽象方法时，方法的后置条件(即方法的返回值)要比父类更严格。
4. 迪米特法则(Law of Demeter): 迪米特法则也叫最少知道原则(Least Knowledge Principle, LKP)，虽然名称不同，但都是同一个意思：一个对象应该对其他对象有最少的了解。迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式有很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说， 陌生的类最后不要作为局部变量的形式出现在类的内部。
5. 接口隔离原则(Interface Segregation Principle): 1).客户端不应该依赖它不需要的接口; 2).类之间的依赖关系应该建立在最小的接口上。接口隔离原则说白了就是，让客户端依赖的接口尽可能地小，接口隔离原则将非常庞大、臃肿的接口拆分成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。接口隔离原则的目的是解耦，从而容易重构。但是，采用接口隔离原则对接口进行约束时要注意，接口尽量小，但要把握好限度。对接口进行细化可以减少代码的臃肿，提供程序的灵活性是不争事实，但是如果接口过小，则会造成接口数量过多，使程序难以维护，反而适得其反。所以一定要适可而止。
6. 依赖倒置原则(Dependence Inversion Principle): 1).上层模块不应该依赖底层模块， 他们都应该依赖于抽象; 2).抽象不应该依赖于细节，细节应该依赖于抽象。依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。 以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。 在java中，抽象指的契约，是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好的规范和而不去设计任何具体的操作，把展示细节的任务交给他们的实现类去完成。依赖倒置原则的核心思想是面向接口编程。
2.说一下抽象类跟接口区别 
3.重写跟重载的区别
定义不同---重载是定义相同的方法名，参数不同；重写是子类重写父类的方法
范围不同---重载是在一个类中，重写是子类与父类之间的
多态不同---重载是编译时的多态性，重写是运行时的多态性
返回不同---重载对返回类型没有要求，而重写要求返回类型，有兼容的返回类型
参数不同---重载的参数个数、参数类型、参数顺序可以不同，而重写父子方法参数必须相同
修饰不同---重载对访问修饰没有特殊要求，重写访问修饰符的限制一定要大于被重写方法的访问修饰符
4.重写equals方法时应该遵循什么原则
1.自反性原则  a.equals(a)
2.对称性原则  a.equals(b) -> b.equals(a)
3.传递性原则  a.equals(b), b.equals(c) -> a.equals(c)
4.一致性原则  a.equals(b)多次调用返回值相同
5.equals和hashcode方法有什么关系
Hashcode是返回的一个hash值，主要用于做对象存储和查找时判断散列位子使用，比如将一个对象存入一个集合中如何快速的定位该对象存放的位子使用hashcode来计算一个hash值，再根据这个值作为下标或者偏移量快速定位对象。
Equals主要用于比较对象使用，默认是比较对象的内存地址，我们可以重写该方法来定义自己的equals方法比较对象，例如我们可以比较对象里的成员变量是否都相等。

Nested Class：
1.有哪几种类别的内部类
2.lambda表达式跟匿名内部类有什么区别
3.使用内部类可以带来哪些好处
4.静态内部类跟普通内部类的区别
5.非静态内部类怎么初始化
6.非静态内部类能不能引用外部类的私有变量或者方法

Test Practice:
1.什么是测试金字塔
2.Mockito mock、spy有什么区别
3.白盒测试，黑盒测试和灰盒测试
4.为什么要进行软件测试

Authorization:
1.访问控制模型包含哪些要素
2.什么是动态职责分离什么是静态职责分离
3.什么是零容忍原则
4.基于角色的访问控制有哪些类型

String：
1.String a = "test"; 创建了几个对象？ -> 常量池
2.字符集和编码是怎么一回事? -> Java中字符串编码是怎样的 -> 介绍下Java常用字符集和默认字符集
3.常用的string 工具类及优缺点 -> 能用自带的split吗?
4.String 是线程安全的吗？不可变的原因和实现实现方法
5.StringBuffer和StringBuilder区别

Regex：	
1.Java中Regex相关的类、接口有什么，用来做什么的
2.Regex中？， +， *各有什么含义？对应的匹配模式是什么
3.讲讲group的含义和使用
4.regex使用会有性能问题吗，通常是什么原因造成的
5. * 和 + 的区别

Spring Security：
1.Spring security包含的主要功能模块及大概原理
2.怎么实现定制化身份认证呢
3.能自定义增强某个功能吗，大致思路
4.有多种登录认证方式，比如用户名密码、手机短信、邮箱，可以配置实现吗

Debug JVM：
1.自己常用的调优工具有哪些，各有什么用
2.怎么配置参数dump出log文件
3.内存泄漏和死锁挑一个讲讲怎么处理
4.谈谈实际调优案例

JVM:
1.从GC的角度谈一谈Java堆的划分
2.GC的触发条件是什么？
3.常见的垃圾回收算法有哪些？
4.谈一谈G1 和 CMS 的对比

Classloading:
1.通过子类引用父类的静态字段，子类会初始化吗？
2.类加载的时机有哪些？
3.字符串常量池是在哪一步生成的？
4.tomcat是如何打破双亲委派机制的？有什么意义？
5.类加载的过程
6.有哪些类加载器

Lock:
1.什么是线程死锁?如何避免死锁?
2.synchronized和volatile的区别
3.synchronized 和 ReentrantLock的区别
4.CAS优缺点
5.什么时候用cas，什么时候该用synchronized?
6.谈一谈对AQS的理解
7.锁升级的过程
8.Lock的优缺点
9.什么是饥饿？

JVM:
1.从GC的角度谈一谈Java堆的划分
2.GC的触发条件是什么？
3.常见的垃圾回收算法有哪些？
4.谈一谈G1 和 CMS 的对比

Collections:
1.谈谈ArrayList和LinkedList的区别
2.谈谈HashMap的底层实现
3.HashMap是线程安全的吗？那如何保证线程安全？
4.讲一讲双轴快排算法

XML parser:
1.xml 解析方式有哪些？区别是什么？ 
2.DOM parser是什么及其优缺点？ 
3.SAX parser是什么及其优缺点？ 
4.SAX parser如何工作的？

Network:
1.TCP协议如何保证可靠性
2.TCP3次握手
3.HTTP1.1和HTTP2.0的区别
4.HTTPS的优缺点
5.在浏览器输入www.baidu.com后执行的过程
6.为什么要进行DNS解析

Reflection
1.什么是反射 -> Java反射机制是指在Java运行时期可以通过反射来获取类型的信息。通过反射使Java能在运行时创建类型对象，调用对象的方法和修改对象的属性，这使得Java语言获得了一定的动态特性。它能够创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代表链接，降低代码的耦合度。反射允许我们在编写与执行时，使我们的程序代码能够接入装载到JVM中的类的内部信息，而不是源代码中选定的类协作的代码。这使反射成为构建灵活的应用的主要工具。但需注意的是：如果使用不当，反射的成本很高。
2.为什么要有反射？反射能帮java解决什么问题 -> 在程序中必须要有类型的引用才能使用对象的方法和属性，这样使得代码和类型产生了高度依赖，当我们的类型做出修改时，我们的代码也得修改来适应类型的改变。而使用反射将使类型和代码解耦，我们只需要知道类文件在哪进而加载类文件就能够获取该类型的信息，可以动态的来使用类型，需要时可以创建该类型对象。主要解决了类型装载和注入的问题，同时解耦类型与代码的依赖。
3.反射有哪些功能 -> 反射的入口类型是Class，它时所有类的类型简称为类类型。通过Class可以获得该类型的信息，可以获得该类型的父类和实现的接口数组，可以通过获得构造方法来创建该类型的对象，访问对象成员变量和成员方法。
4.反射的优缺点 -> 
    优点: 1.增加程序的灵活性，可以在运行的过程中动态对类进行修改和操作;2.提高代码的复用率，比如动态代理、spring管理bean，就是用到反射来实现的;3.可以在运行时轻松获取任意一个类的方法、属性，并且还能通过反射进行动态调用。
    缺点: 1.反射会涉及到动态类型的解析，所以jvm无法对这些代码进行优化，导致性能要比非反射调用更低; 2.使用反射以后，代码的可读性会下降; 3.反射可以绕过一些限制访问的属性或者方法，可能会导致破坏代码本身的抽象性和封装性。
5.Spring框架中是怎么使用反射的？
    

Kafka:
1.简述Kafka架构中包含的哪些核心组件，以及它们各自的功能是什么？
2.如何保证Topic的数据是全局有序的？
3.Kafka Broker处理速度快的原因?
4.简述Kafka数据一致性机制（ISR+OSR）

RabbitMQ:
1.RabbitMQ的结构设计，包含哪些组件，分别有什么功能？
2.Exchange的四种类型以及用法
3.RabbitMQ的消息模式
4.简述死信队列和TTL

注解：
1.什么是注解: 注解是JDK5之后提供的一种技术，使用方法就是@+名称 就可以对类、方法、属性添加一些描述性的内容。JDK有很多内置注解比如:@override, @deprecated, @SuppressWarnings。在创建注解使需要使用元注解来定义新建注解的如何使用。
2.@Retention有什么用: 元注解指定注解在什么阶段使用，对于当前代码而言：1. Source:源代码阶段使用，该注解信息只在源文件里保存，当源代码被编译后，注解信息将被丢弃，不会保存在编译好的class文件里面；2. Class:字节码阶段使用，该注解信息只会保存在class字节码里面，当加载到JVM里运行被丢弃；3. Runtime: 运行时阶段使用，该注解信息会保存在JVM运行期，因此可以通过反射来读取该注解的信息。
3.@Target有什么用: 元注解指定注解的作用范围。比如注解可以作用在类、接口或enum上，也可以作用在成员属性上，也可以作用在成员方法上等；
4.注解处理器的概念和作用

泛型：
1.什么是泛型擦除机制？为什么要擦除？--> 泛型是jdk1.5才引入的特性，在此之前的版本是没有泛型概念的，但是泛型代码能很好的兼容jdk1.5之前的代码，那是因为泛型只存在泛型编译阶段，在进入JVM运行之前，与泛型相关的信息都会被擦除，我们称之为泛型擦除。针对类型擦除又分为无限制的类型擦除和有限制的类型擦除，无限制的类型擦除通常会被擦除成Object类型，而对于有限制的类型擦除<? extends T>通常会被擦除成泛型标识符的实参类型。而对于泛型方法的擦除与泛型类的擦除类似。在对泛型接口的重写时要注意有个桥接方法来桥接实现类方法和泛型接口擦除后的方法。
2.什么是泛型中的限定通配符和非限定通配符? --> 类型通配符是使用？来代替具体的实参类型，所以类型通配符是类型实参而不是类型形参。 类型通配符上限<? extends 实参类型>指定泛型类型只能是实参类型或者是实参类型的子类类型。类型通配符下限<? super 实参类型>指定泛型类型只能是实参类型或者是实参类型的父类类型。
3.List<? extends T>和List <? super T>之间有什么区别? -->List<? extends T>的实参只能是T或者T的子类类型，同时无法向list中添加元素。List <? super T>的实参只能是T或T的父类类型，可以向list中添加元素，但不保证类型，用Object类型接受。
4.`ArrayList<String>`与`ArrayList<Integer>`是否相等？-->相等

Java Logging:
1.系统日志和业务日志的区别？
2.项目中日志是怎么实现的？为什么要使用elk+kafka（原理）？
3.微服务链路追踪是怎么实现的？
4.MDC与NDC有何不同？

OWASP:
1.SQL注入是什么？如何防止SQL注入？
2.什么是XSS？
3.什么是CSRF？
4.XSS与CSRF的区别

序列化:
1. Java序列化与反序列化是什么
2. Java序列化实现的方式有哪些
3. Java序列化中如果有些字段不想进行序列化，怎么办
4. 静态变量会被序列化吗
5. SerialVersionUID有什么用处

多线程
1.多线程编程的3要素是什么
2.线程池的工作原理以及参数讲解
3.什么是守护线程
4.什么是ThreadLocal,有什么潜在问题
5.volatile有什么作用
6.线程有哪些状态
7.什么是用户线程和内核线程

CICD:
1.CICD 和敏捷开发的关系是怎样的？
2.CICD中有哪些重要的元素？
3.CICD最重要的特性有哪些？
4.CICD有哪些好处？

IO/NIO
1.BIO, NIO, AIO 是什么以及他们有哪些差异？
2.什么是NIO, NIO中有哪些组件
3.字节流和字符流的区别是什么？他们是怎么转化的？
4.说一说传统IO中的设计模式

Authentication
1.什么是JWT？
2.JWT的优缺点是什么？
3.什么是SSO?

强、软、弱、虚引用
强引用：最常使用的引用，我们使用一个引用指向一个对象时，该引用就是强引用，对于强引指向的对象是不会被Java垃圾回收机制回收的；
软引用：java.lang.ref.SoftReference 首先，软引用本身就是一个对象，这个对象内有个引用通过get()方法获得，这个引用就是软引用，使用这个软引用指向的对象当堆空间不足时就会被Java垃圾回收器回收，常用在缓存中；
弱引用：java.lang.ref.WeakReference 弱引用的概念其实跟软引用差不多，区别在于软引用是堆空间不足才回收软引用对象，而弱引用对象是只要Java垃圾回收就被回收，常用于存在内存泄露的场景；
虚引用：java.lang.ref.PhantomReference 虚引用指向的对象是无法通过get()获得的，其实虚引用是一种监听GC的机制，当Java垃圾回收把虚引用指向的对象回收了，就会将一个关于这次回收的信息放入一个队列中，程序可以重队列中取出消息处理。常用于DirectByteBuffer对堆外内存的管理。
