## Git 合并

### Git 合并概述
在Git中，合并必须发生在一个版本库中———也就是说，所有要进行合并的分支必须在同一个版本库中。版本库中的分支是怎么来的并不重要。当一个分支中的修改与另一个分支中的修改不发生冲突的时候，Git会计算合并结果，并创建一个新提交来代表新的统一状态。但是当分支冲突时，Git并不解决冲突，这通常出现在对同一个文件的同一行进行修改的时候。相反，Git把这种争议性的修改在索引中标记为“未合并”(unmerged)，留给你(也就是开发人员)来处理。当Git无法自动合并时，你需要在所有冲突都解决后做一次最终提交。
>不必从干净的目录启动合并。例如，当受合并操作影响的文件和工作目录的脏文件无关的时候，Git才进行合并，然而，作为一般规则，如果每次合并都从干净的工作目录和索引开始，那么关于GIt的操作将会容易的多。
从技术上讲，Git对称地执行每次合并来产生一个相同的、合并后的提交，并添加到当前分支中。另一个分支不受影响。因为合并提交只添加到当前分支中，所以你可以说：“我把一些其他分支合并到了这个分支里”。

### 有冲突的合并和解决冲突
合并操作本质上是有问题的，因为它必然从不同的开发线上带来可能变化和冲突的修改。一个分支上的修改可能与一个不同分支上的相似或完全不同。当在当前工作分支上进行合并时，可以使用`git diff`来显示文件在工作目录和索引之间的差异。在传统的diff命令输出风格里，改变的内容显示在<<<<<<<<和========之间，代替的内容在========和>>>>>>>>之间。然而，在组合diff(combined diff)格式中使用额外的加号和减号来表示相对于最终版本的来自多个源的变化。当解决冲突时，可以自由选择你喜欢的任何解决方案。这句话只取一边或另一边的版本，或者两边的混合，甚至是全新的内容。最后当你对冲突文件修改满意时，可以用`git add`将修改文件加入索引并用`git commit`来提交或者直接用`git commit -am`来提交你的最终修改。
>Git冲突合并产生的结果是两个diff文件的简单组合：一个对应第一个称为HEAD的父版本，另一个对应第二个称为要合并分支的父版本，为了简单记忆，Git也给第二个父版本起了一个特殊的名字————MERGE_HEAD。在较新版本的Git中，`git diff --ours`是`git diff HEAD`的同义词，因为它显示了“我们的”版本和合并版本的区别。同样，`git diff MERGE_HEAD`可以写成`git diff --theirs`。可以用`git diff --base`命令来查看自合并基础之后的变更组合，否则也可以相当繁琐地写成：`git diff $(git merge-base HEAD MERGE_HEAD)`
对有冲突的文件执行`git diff`只会显示真正有冲突的部分。在一个充满很多修改的大文件里，大部分修改是没有冲突的；只是在一边改变了一个特定的部分。当你试图解决冲突时，很少会在乎那些不用修改的部分，因此`git diff`命令用一个简单的启发式算法修剪掉不感兴趣的部分：如果只有一边有变化，这部分就不显示了。

### 如何追踪冲突
Git是如何追踪合并冲突的，主要有以下几个方面：
* .git/MERGE_HEAD包含合并进来的提交的SHA1值。
* .git/MERGE_MSG包含当解决冲突后执行`git commit`命令时用到的默认合并消息。
* Git的索引包含每个冲突文件的三个副本：合并基础、“我们的”版本和“他们的”版本。给这三个副本分配了各自的编号1、2、3。最后解决了冲突并提交更新后，Git就把索引再次简化为只有一份编号0的文件副本。
* 冲突的版本不存在索引中。相反，它存储在工作目录中的文件里。当执行不带参数的`git diff`命令时，始终比较索引和工作目录中的内容。
>要查看索引是如何存储的，可以使用`git ls-files`底层命令。-s参数可以查看所有文件的各个阶段。如果你只想看冲突文件请使用-u选项。
>```
>$ git ls-files -u
>100644 ce013625030ba8dba906f756967f9e9ca394464a 1       hello
>100644 e63164d9518b1e6caf28f455ac86c8246f78ab70 2       hello
>100644 562080a4c6518e1bf67a9f58a32a67bff72d4f00 3       hello
>```
>也可以用`git cat-file -p SHA1哈希值`来查看文件内容。
>```
>$ git cat-file -p ce013625
>hello
>```
>还可以用`git diff`的一些特殊语法来比较文件的不同版本。
>```
>$ git diff :1:hello :3:hello
>diff --git a/:1:hello b/:3:hello
>index ce01362..562080a 100644
>--- a/:1:hello
>+++ b/:3:hello
>@@ -1 +1,3 @@
> hello
>+world
>+Yay!
>```
>还可以通过`git log`的选项参数来查看是由哪些提交引入了冲突。
>* --merge：只显示跟产生冲突的文件相关的提交。
>* --left-right：如果提交来自合并的“我们的”版本，就是你开始的版本则显示<,如果提交来自合并的“他们的”版本，就是你要合并的版本则显示>。
>* -p：显示提交消息的每个提交相关的补丁。

放弃合并可以使用`git reset --hard HEAD`,如果已经引入了一个合并提交后想放弃合并，回复以前的状态可以使用`git reset --hard ORIG_HEAD`，Git把原始分支的HEAD保存在ORIG_HEAD。但是需要非常小心，如果在工作目录或索引不干净的情况下启动，可能会丢失目录中没提交的修改。
