## Git 合并

### Git 合并概述
在Git中，合并必须发生在一个版本库中———也就是说，所有要进行合并的分支必须在同一个版本库中。版本库中的分支是怎么来的并不重要。当一个分支中的修改与另一个分支中的修改不发生冲突的时候，Git会计算合并结果，并创建一个新提交来代表新的统一状态。但是当分支冲突时，Git并不解决冲突，这通常出现在对同一个文件的同一行进行修改的时候。相反，Git把这种争议性的修改在索引中标记为“未合并”(unmerged)，留给你(也就是开发人员)来处理。当Git无法自动合并时，你需要在所有冲突都解决后做一次最终提交。
>不必从干净的目录启动合并。例如，当受合并操作影响的文件和工作目录的脏文件无关的时候，Git才进行合并，然而，作为一般规则，如果每次合并都从干净的工作目录和索引开始，那么关于GIt的操作将会容易的多。
从技术上讲，Git对称地执行每次合并来产生一个相同的、合并后的提交，并添加到当前分支中。另一个分支不受影响。因为合并提交只添加到当前分支中，所以你可以说：“我把一些其他分支合并到了这个分支里”。

### 有冲突的合并和解决冲突
合并操作本质上是有问题的，因为它必然从不同的开发线上带来可能变化和冲突的修改。一个分支上的修改可能与一个不同分支上的相似或完全不同。当在当前工作分支上进行合并时，可以使用`git diff`来显示文件在工作目录和索引之间的差异。在传统的diff命令输出风格里，改变的内容显示在<<<<<<<<和========之间，代替的内容在========和>>>>>>>>之间。然而，在组合diff(combined diff)格式中使用额外的加号和减号来表示相对于最终版本的来自多个源的变化。当解决冲突时，可以自由选择你喜欢的任何解决方案。这句话只取一边或另一边的版本，或者两边的混合，甚至是全新的内容。最后当你对冲突文件修改满意时，可以用`git add`将修改文件加入索引并用`git commit`来提交或者直接用`git commit -am`来提交你的最终修改。
>Git冲突合并产生的结果是两个diff文件的简单组合：一个对应第一个称为HEAD的父版本，另一个对应第二个称为要合并分支的父版本，为了简单记忆，Git也给第二个父版本起了一个特殊的名字————MERGE_HEAD。在较新版本的Git中，`git diff --ours`是`git diff HEAD`的同义词，因为它显示了“我们的”版本和合并版本的区别。同样，`git diff MERGE_HEAD`可以写成`git diff --theirs`。可以用`git diff --base`命令来查看自合并基础之后的变更组合，否则也可以相当繁琐地写成：`git diff $(git merge-base HEAD MERGE_HEAD)`
对有冲突的文件执行`git diff`只会显示真正有冲突的部分。在一个充满很多修改的大文件里，大部分修改是没有冲突的；只是在一边改变了一个特定的部分。当你试图解决冲突时，很少会在乎那些不用修改的部分，因此`git diff`命令用一个简单的启发式算法修剪掉不感兴趣的部分：如果只有一边有变化，这部分就不显示了。

### 如何追踪冲突
Git是如何追踪合并冲突的，主要有以下几个方面：
* .git/MERGE_HEAD包含合并进来的提交的SHA1值。
* .git/MERGE_MSG包含当解决冲突后执行`git commit`命令时用到的默认合并消息。
* Git的索引包含每个冲突文件的三个副本：合并基础、“我们的”版本和“他们的”版本。给这三个副本分配了各自的编号1、2、3。最后解决了冲突并提交更新后，Git就把索引再次简化为只有一份编号0的文件副本。
* 冲突的版本不存在索引中。相反，它存储在工作目录中的文件里。当执行不带参数的`git diff`命令时，始终比较索引和工作目录中的内容。
>要查看索引是如何存储的，可以使用`git ls-files`底层命令。-s参数可以查看所有文件的各个阶段。如果你只想看冲突文件请使用-u选项。
>```
>$ git ls-files -u
>100644 ce013625030ba8dba906f756967f9e9ca394464a 1       hello
>100644 e63164d9518b1e6caf28f455ac86c8246f78ab70 2       hello
>100644 562080a4c6518e1bf67a9f58a32a67bff72d4f00 3       hello
>```
>也可以用`git cat-file -p SHA1哈希值`来查看文件内容。
>```
>$ git cat-file -p ce013625
>hello
>```
>还可以用`git diff`的一些特殊语法来比较文件的不同版本。
>```
>$ git diff :1:hello :3:hello
>diff --git a/:1:hello b/:3:hello
>index ce01362..562080a 100644
>--- a/:1:hello
>+++ b/:3:hello
>@@ -1 +1,3 @@
> hello
>+world
>+Yay!
>```
>还可以通过`git log`的选项参数来查看是由哪些提交引入了冲突。
>* --merge：只显示跟产生冲突的文件相关的提交。
>* --left-right：如果提交来自合并的“我们的”版本，就是你开始的版本则显示<,如果提交来自合并的“他们的”版本，就是你要合并的版本则显示>。
>* -p：显示提交消息的每个提交相关的补丁。

放弃合并可以使用`git reset --hard HEAD`,如果已经引入了一个合并提交后想放弃合并，回复以前的状态可以使用`git reset --hard ORIG_HEAD`，Git把原始分支的HEAD保存在ORIG_HEAD。但是需要非常小心，如果在工作目录或索引不干净的情况下启动，可能会丢失目录中没提交的修改。


### 合并策略
1. 退化合并：有两种情况导致退化合并，分别是最新的（already up-to-date）和快进的（fast-forward）。因为这些情况下执行`git merge`后实际都不引入一个合并提交，所以有些人可能认为它们不是真正的合并提交。
* 已是最新的。当来自其他分支（HEAD）的所有提交都存在于目标分支上时，即使它已经在自己的分支上前进了，目标分支还是已经是更新到了最新的。因此，没有新的提交添加到你的分支上。
* 快进的：当分支HEAD已经在其他分支中完全存在或表示时，就会发生快进合并。因为HEAD已经在其他分支上存在了，Git简单地把其他分支的新提交钉在HEAD上。然后Git移动分支HEAD来指向最终的新提交。块进合并的情况是相当常见的，因为他们只是简单获取并记录来自其他版本库的远程提交。
2. 常规合并：这些合并都会产生一个最终提交，添加到当前分支中，表示合并的组合状态。
* 解决（Resolve）：解决策略只操作两个分支，定位共同的祖先作为合并基础，然后执行一个直接的三方合并，通过对当前分支施加从合并基础到其他分支HEAD的变化。
* 递归（Recursive）：递归策略跟解决策略很相似，它一次只能处理两个分支。然而，它能处理在两个分支之间有多个合并基础的情况。在这种情况下，Git会生成一个临时合并包含所有相同的合并基础，然后以此为基础，通过一个普通的三方合并算法导出两个给定分支的最终合并。扔掉临时合并基础，把最终合并状态提交到目标分支。
* 章鱼（Octopus）：章鱼策略是专门合并两个以上分支而设计的。从概念上讲，它相当简单；在内部，它多次调用递归合并策略，要合并的每个分支调一次。然而这种策略不能处理需要用户交互解决的冲突。在这种情况下，必须做一系列常规合并，一次解决一个冲突。
3. 特殊提交：有两个特别的合并策略你应该知道，因为它们有时候能帮你解决一些奇怪的问题。这些合并策略每个都产生一个最终提交，添加到当前分支中，代表组合并状态。
* 我们的（ours）：这个策略合并任何数量的其他分支，但它实际上丢弃那些分支的修改，只使用当前分支的文件。“我们的”合并结果跟当前HEAD是相同的，但是任何其他分支也记为父提交。这是非常有用的，如果你知道你已经有了其他分支的所有变化，但想一定要把两个历史合并起来。也就是说，它可以让你记录你已经以某种方式进行合并，也许直接动手，未来的Git操作不应该再尝试合并这些历史。无论它是如何成为合并的，Git都可以把这个当成真实合并。
* 子树（subtree）：子树策略合并到另一个分支，但是那个分支的一切会合并到当前树的一颗特定子树。不需要指定哪棵子树，Git会自动决定。