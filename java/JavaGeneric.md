### Java 泛型
Java SE5的重大变化之一，泛型的概念。泛型实现了参数化类型的概念，使代码可以应用于多种类型。
“泛型”这个术语的意思是：“适用于许多的类型”。泛型在编程语言中出现时，其最初的目的是希望
类或方法能够具备最广泛的表达能力。如何做到这一点呢，正是通过解耦类或方法与使用的类型之间的
约束。

###### 简单的泛型
在有些情况下，我们希望容器能够同时持有多种类型的对象。但是，通常而言，我们只会使用容器来存
储一种类型的对象。泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器来保
证类型的正确性。这就是Java泛型的核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一切
细节。一般常用的简单泛型场景就是集合类，JDK 1.5以后所有的集合类都接受参数化类型，这样在实际
使用集合类时就可以指定类型参数明确集合类里持有的是什么类型，将具体的细节交给编译器去处理。
**需要注意的是Java中泛型和Java的继承特性并不冲突，指定的泛型可以接受参数类型的子类型。**

###### 泛型接口
同简单泛型一样，Java的接口也可以接受参数类型。比较常用的例子就是Iterable泛型接口，在接口中
指定参数类型后，实现了该接口的类中进行循环时，就可以不需要担心类型错误。虚拟机会处理指定的
参数类型。**基本类型无法作为参数类型传给泛型。**

###### 泛型方法
泛型也可以应用在方法上，这种使用泛型方式与泛型方法所在的类是不是泛型没有关系。泛型方法使得
该方法能够独立于类而产生变化。以下是一个基本的指导原则：无论何时，只要你能做到，你就应该尽
量使用泛型方法。也就是说，如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法
，因为它可以是事情更清楚明白。另外，**对于一个static的方法而言，无法访问泛型类的类型参数，所
以，如果static方法需要使用泛型能力，就必须使其成为泛型方法。** 注意： 当使用泛型类时，
必须在创建对象的时候指定类型参数的值，而使用泛型方法时候，通常不必指明参数类型，因为编译器
会为我们找出具体的类型。这称为类型参数推断(type argument inference)。

###### 泛型的擦除
在泛型代码内部，无法获得任何有关泛型参数类型的信息。你可以通过Class.getTypeParameters()返回
一个TypeVariable对象数组，表示有泛型声明所声明的类型参数。但是其真正返回的是类型参数标识符和
泛型类型边界这类的信息，这并非是获得了传入泛型的类型信息，你无法通过这些信息来创建某个特定实
例的实际的类型参数。Java泛型是使用擦除类实现的，这意味着当你在使用泛型时，任何具体的类型信息
都被擦除了，你唯一知道的就是你在使用一个对象。例如List<String>和List<Integer>在运行时事实上
是相同的类型。这两种形式都被擦除成它们的“原生”类型，即List。理解擦除以及应该如何处理它，是
学习Java泛型面临的最大障碍，这也是我们学习的重点。
当在程序中需要使用泛型参数类型的信息时就必须要用到泛型边界，我们说泛型类型参数将擦除到它的第
一个边界(它可能有很多边界)，我们还提到了类型参数的擦除。编译器实际上会把类型参数替换成为它的
擦除。这提出了很重要的一点：**只有当你希望使用的类型参数比某个具体类型(以及它的所有子类型)
更加“泛化”时——也就是说，当你希望代码能够跨多个类工作时，使用泛型才有所帮助。因此，
类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换要更复杂。但是，不能因此而认为
<T extends classname>形式的任何东西都是有缺陷的。必须查看所有的代码，并确定它是否“足够复
杂”到必须使用泛型的程度。**
Java泛型的擦除的主要原因是为了向后兼容，Java泛型是JDK 1.5才加入的新特性，所以才使用擦除这种
折中的实现办法。在基于擦除的实现中，泛型类型被当做第二类类型处理，即不能再某些重要的上下文环
境中使用的类型。泛型类型只能在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦
除，替换为它们的非泛型上界。因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及
在不破坏现有类库的情况下，将泛型融入Java语言。擦除使得现有的非泛化型客户端代码能够在不改变的
情况下继续使用，直至客户端准备好用泛型重写这些代码。擦除的代价是显著的。泛型不能用于显式地引
用运行时类型的操作之中，例如转型、instanceof操作和new表达式。因为所有关于参数的类型信息都丢
失了，无论何时，当你在编写泛型代码时，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信
息而已。

###### 泛型数组
在Java中永远无法创建这个确定类型的数组(包括类型参数)，因此这有一点令人困惑。既然所有数组无论
它们持有的类型如何，都具有相同的结构(每个数组槽位的尺寸和数组的布局)，那么看起来你应该能够创
建一个Object数组，并将其转型为所希望的数组类型。事实上这可以编译，但是不能运行，它将产生ClassCaseException
。问题在于数组将跟踪它们的实际类型，而这个类型是在数组被创建时确定的。所以成功创建泛型数组的
唯一方式就是创建一个被擦除类型的新数组，然后对其转型。因为有了擦除，数组的运行时类型就只能是
Object[]。如果我们立即将其转型为T[]，那么在编译期该数组的实际类型就将丢失，而编译器可能会错
过某些潜在的错误检查。正因为这样，最好是在集合内部使用Object[]，然后当你使用数组元素时，添加
一个对T的转型。

###### 泛型边界
边界使得你可以在用于泛型的参数类型上设置限制条件。尽管这使得你可以强制规定泛型可以应用的类型
，但是其潜在的一个更重要的效果是你可以按照自己的边界类型来调用方法。因为擦除移除了类型信息，
所以，可以用无界泛型参数调用的方法只是那些可以用Object调用的方法。但是，如果能够将这个参数限
制为某个类型子集，那么你就可以用这些类型子集来调用方法。为了执行这种限制，Java泛型重用了extends
关键字。对你来说有一点很重要，即要理解extends关键字在泛型边界上下文环境中和在普通情况下所具有
的意义是完全不同的。

###### 泛型通配符
* 子类型通配符：持有类可读；
* 超类型通配符：持有类可写；
* 无界通配符：与原生类类似，但是只能读不能写。

