### Java 泛型
Java SE5的重大变化之一，泛型的概念。泛型实现了参数化类型的概念，使代码可以应用于多种类型。“泛型”这个术语的意思是：“适用于许多的类型”。泛型在编程语言中出现时，其最初的目的是希望类或方法能够具备最广泛的表达能力。如何做到这一点呢，正是通过解耦类或方法与使用的类型之间的约束。

###### 简单的泛型
在有些情况下，我们希望容器能够同时持有多种类型的对象。但是，通常而言，我们只会使用容器来存储一种类型的对象。泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性。这就是Java泛型的核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一切细节。一般常用的简单泛型场景就是集合类，JDK 1.5以后所有的集合类都接受参数化类型，这样在实际使用集合类时就可以指定类型参数明确集合类里持有的是什么类型，将具体的细节交给编译器去处理。**需要注意的是Java中泛型和Java的继承特性并不冲突，指定的泛型可以接受参数类型的子类型。**

###### 泛型接口
同简单泛型一样，Java的接口也可以接受参数类型。比较常用的例子就是Iterable泛型接口，在接口中指定参数类型后，实现了该接口的类中进行循环时，就可以不需要担心类型错误。虚拟机会处理指定的参数类型。**基本类型无法作为参数类型传给泛型。**

###### 泛型方法
泛型也可以应用在方法上，这种使用泛型方式与泛型方法所在的类是不是泛型没有关系。泛型方法使得该方法能够独立于类而产生变化。以下是一个基本的指导原则：无论何时，只要你能做到，你就应该尽量使用泛型方法。也就是说，如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法，因为它可以是事情更清楚明白。另外，**对于一个static的方法而言，无法访问泛型类的类型参数，所以，如果static方法需要使用泛型能力，就必须使其成为泛型方法。** 注意： 当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法时候，通常不必指明参数类型，因为编译器会为我们找出具体的类型。这称为类型参数推断(type argument inference)。

###### 泛型的擦除
在泛型代码内部，无法获得任何有关泛型参数类型的信息。你可以通过ClassgetTypeParameters()返回一个TypeVariable对象数组，表示有泛型声明所声明的类型参数。但是其真正返回的是类型参数标识符和泛型类型边界这类的信息，这并非是获得了传入泛型的类型信息，你无法通过这些信息来创建某个特定实例的实际类型参数。Java泛型是使用擦除类实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。例如`List<String>`和`List<Integer>`在运行时事实上是相同的类型。这两种形式都被擦除成它们的“原生”类型，即List。理解擦除以及应该如何处理它，是学习Java泛型面临的最大障碍，这也是我们学习的重点。当在程序中需要使用泛型参数类型的信息时就必须要用到泛型边界，我们说泛型类型参数将擦除到它的第一个边界(它可能有很多边界)，我们还提到了类型参数的擦除。编译器实际上会把类型参数替换成为它的擦除。这提出了很重要的一点：**只有当你希望使用的类型参数比某个具体类型(以及它的所有子类型)更加“泛化”时——也就是说，当你希望代码能够跨多个类工作时，使用泛型才有所帮助。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换要更复杂。但是，不能因此而认为<T extends classname>形式的任何东西都是有缺陷的。必须查看所有的代码，并确定它是否“足够复杂”到必须使用泛型的程度。**Java泛型的擦除的主要原因是为了向后兼容，Java泛型是JDK 1.5才加入的新特性，所以才使用擦除这种折中的实现办法。在基于擦除的实现中，泛型类型被当做第二类类型处理，即不能再某些重要的上下文环境中使用的类型。泛型类型只能在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入Java语言。擦除使得现有的非泛化型客户端代码能够在不改变的情况下继续使用，直至客户端准备好用泛型重写这些代码。擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作之中，例如转型、instanceof操作和new表达式。因为所有关于参数的类型信息都丢失了，无论何时，当你在编写泛型代码时，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信息而已。

###### 泛型数组
在Java中永远无法创建这个确定类型的数组(包括类型参数)，因此这有一点令人困惑。既然所有数组无论它们持有的类型如何，都具有相同的结构(每个数组槽位的尺寸和数组的布局)，那么看起来你应该能够创建一个Object数组，并将其转型为所希望的数组类型。事实上这可以编译，但是不能运行，它将产生ClassCaseException。问题在于数组将跟踪它们的实际类型，而这个类型是在数组被创建时确定的。所以成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组，然后对其转型。因为有了擦除，数组的运行时类型就只能是Object[]。如果我们立即将其转型为T[]，那么在编译期该数组的实际类型就将丢失，而编译器可能会错过某些潜在的错误检查。正因为这样，最好是在集合内部使用Object[]，然后当你使用数组元素时，添加一个对T的转型。

###### 泛型边界
边界使得你可以在用于泛型的参数类型上设置限制条件。尽管这使得你可以强制规定泛型可以应用的类型，但是其潜在的一个更重要的效果是你可以按照自己的边界类型来调用方法。因为擦除移除了类型信息，所以，可以用无界泛型参数调用的方法只是那些可以用Object调用的方法。但是，如果能够将这个参数限制为某个类型子集，那么你就可以用这些类型子集来调用方法。为了执行这种限制，Java泛型重用了extends关键字。对你来说有一点很重要，即要理解extends关键字在泛型边界上下文环境中和在普通情况下所具有的意义是完全不同的。

###### 泛型通配符
* 子类型通配符：持有类可读；
* 超类型通配符：持有类可写；
* 无界通配符：与原生类类似，但是只能读不能写。

###### 再看泛型
泛型的背景：在泛型出现之前，Java中创建的集合类型都是Object，使用集合元素时，很容易造成类型转换异常ClassCastException。而且往往这种异常到了编译期才被抛出，为了避免这种类型转换造成的异常JDK5引入了新特性java泛型（generic）。泛型提供了编译期类型安全监测机制，该机制允许我们在编译时检测到非法的类型数据解构。泛型的本质就是类型参数化，就是指定类型参数达到代码的复用。

###### 泛型类、接口
泛型类的定义语法，常用的泛型标识有T、E、K、V
```
class 类名称 <泛型标识, 泛型标识...>{
  private 泛型标识 变量名；
  ...
}

类名<具体的数据类型> 变量名 = new 类名<>();
```
使用泛型类时的注意事项：
* 当泛型类在使用时没有指明具体的参数类型，那么默认将使用Object类型；
* 泛型参数只能是类类型不能是基本数据类型；
* 泛型类在逻辑上可以看成不同的类型，但是实质是同一种类型。

从泛型类派生子类时需要注意两点：
* 子类也是泛型类，子类中的泛型类型至少有一个和父类的泛型类型要保持一致；
* 如果子类不是泛型类，那么父类需要明确泛型类型。

泛型接口的定义语法：
```
interface 接口名称 <泛型标识, 泛型标识...>{
  T 方法名();
}
```
泛型接口使用的注意事项：
* 当实现类也是泛型类时，实现类的泛型类型中至少有一个要和泛型接口的泛型类型保持一致；
* 当实现类不是泛型类时，需要指定泛型接口的类型参数。

###### 泛型方法
泛型方法的定义语法
```
访问修饰符 <T, E...> 返回类型 方法名(形参列表){
  方法体
}
```
只有在访问修饰符和返回类型之间定义了泛型标识符的方法才是泛型方法，当定义了泛型标识符后就可以在方法中使用泛型类型，使用范围可以使返回类型、形参列表或者方法体。常用的泛型标识符有T、E、K、V。
使用泛型方法的注意事项：
* 泛型方法的泛型标识主要用于形参列表和方法返回值；
* 泛型类的方法使用了泛型类定义的泛型标识那么将不能被定义成static静态方法，而泛型方法可以被定义成一个静态方法；
* 泛型方法可以使方法独立于类而产生变化；

###### 类型通配符
类型通配符使用？来代替具体的实参类型，所以类型通配符使类型实参而不是类型形参。
* 类型上限通配符指定了泛型类型只能是实参类型或者是实参类型的子类类型，定义语法如下：
```
类\接口<? extends 实参类型>
```
* 类型下限通配符指定了泛型类型只能是实参类型或者是实参类型的父类类型，定义语法如下：
```
类\接口<? super 实参类型>
```

###### 泛型擦除
泛型是jdk1.5才引入的特性，在此之前的版本是没有泛型概念的，但是泛型代码能很好的兼容jdk1.5之前的代码，那是因为泛型只存在泛型编译阶段，在进入JVM运行之前，与泛型相关的信息都会被擦除，我们称之为泛型擦除。针对类型擦除又分为无限制的类型擦除和有限制的类型擦除，无限制的类型擦除通常会被擦除成Object类型，而对于有限制的类型擦除<? extends T>通常会被擦除成泛型标识符的实参类型。而对于泛型方法的擦除与泛型类的擦除类似。在对泛型接口的重写时要注意有个桥接方法来桥接实现类方法和泛型接口擦除后的方法。

###### 泛型与数组
1. 可以声明一个泛型数组的引用，但是不能创建泛型数组的对象。这两者时冲突的，因为泛型数组在编译期需要擦除泛型的类型信息，而数组在整个编译期都需要保存类型信息，所以无法创建一个泛型数组对象。
2. 可以通过反射java.lang.reflect.Array的`newInstance<Class<T>, int>`来创建泛型数组T[]。

###### 泛型与反射
Class类和Constructor都支持泛型。
